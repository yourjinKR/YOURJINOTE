# 기초 학습


# 문제 풀이
[백준 단계별 풀이 : 진법 전환 1](https://github.com/yourjinKR/javaBasic/commit/c7d9249ece0ce5464313b514859f46590b1cfdcd)

# 팀 프로젝트



---

# AI 사용에 대해
AI에게 질문을 하고 다시 수정하거나 재질문에서 답변을 받는 것은 AI를 그저 도구로 사용하는 것이라고 생각한다.  
AI가 나의 니즈에 맞지 않는 답변을 한다면 결과를 수정하는 것이 아닌 해당 모델의 프롬프트를 수정하는 것이  좋은 방향성이라고 생각합니다.

---

# 불변 객체와 String 클래스


# 불변 객체

- 모든 필드를 `final` 선언하여 상수화한 클래스 (무결성)
	- 필드 초깃값을 기술할 수 있는 부분 제외 (생성자 혹은 초깃값 정의)
- 필드 값을 변경시에는 새로운 사본 인스턴스를 수정된 초깃값으로 기술하여 반환 (원자성)
	- 해당 방식은 비효율적일 수 있으나 멀티스레딩 환경에서 장점이 있다.
- 대표 예시 : String, Wrapper Class

# 문자 상수와 String

- 문자열의 본질은 문자 배열이며 문자열은 인코딩 규칙에 영향을 받음 
	- `char[]`, `String` 
	- 문자 배열은 겹따옴표를 이용한 리터럴 표기 가능 
	- Java 9이후 `char[]`에서 `byte[]`로 변경
- `String` 클래스는 불변 클래스이며 논리적 의미로 기본 형식에 속하는 특성을 보임 
- 덧셈 연산의 결과로 **임시 객체**가 생기는 문제가 있음 
- 큰 문자열을 다룰 경우 효율이 더 떨어짐

# 문자열 비교
- 상등 연산으로 두 String 클래스 인스턴스를 비교할 경우 심각한 논리적 문제가 발생할 수 있다.
	- 문자열 상수 풀
	- JVM이 클래스 로딩 시 미리 인스턴스 생성
- `equals()` 메서드를 활용하거나 `compareTo()` 메서드로 문자열 비교하는 것이 적절

```java
String s1 = "Hello";
String s2 = "Hello"; 
System.out.println(s1 == s2) // true
System.out.println(s1.equals(s2)); // true

String s3 = new String("World");
String s4 = new String("World");
System.out.println(s3 == s4); // false
System.out.println(s3.equals(s4)); // true
System.out.println(s3.compareTo(s4) == 0); // true
```

# 문자열 주요 메서드
생략

# Java가 문자열을 관리하는 구조

- 모든 문자열은 상수 풀로 관리
- C/C++로 개발된 PE 파일과 유사한 구조

> exe 파일의 내부에 문자열이 포함  
> 실행 코드가 저장되는 정적메모리 영역에 문자열 상수 저장  
> 같은 문자열 상수에 대한 포인터의 주소는 모두 동일

- 코드상 존재하는 모든 문자열 상수는 Class가 로딩될 때 Runtime constant pool에 등록된 후 힙 영역에 존재하는 String constant pool에도 추가

### `String.intern()`

```java
public native String intern();
```

> `native` : C/C++로 구현된 메서드에 붙이는 예약어

- 문자열 상수 풀에서 문자열을 조회하고 반환
	- 문자열 상수와 일치하는 문자열을 상수 풀에서 검색
	- 찾으면 이미 **생성되어 있는 String 인스턴스** 반환
	- 없으면 새로 **String 객체 생성 후 풀에 추가**하고 반환

> 문자열 상수 풀은 힙 영역에 속하며 GC 대상이다.

![Pasted image 20251210230000](GALLERY/Pasted%20image%2020251210230000.png)

# StringBuilder


# Wrapper Class

- 기본 데이터 형식은 클래스가 아니므로 메소드를 가지지 못함
- 이 문제를 해결하기 위해 기본 데이터 형식을 클래스로 만드는 것이 Wrapper Class
	- Byte, Character
	- Short
	- Integer, Long
	- Float, Double
	- Boolean

# Boxing과 UnBoxing

```java
Integer num1 = new Integer(123); // 박싱
int num2 = num1.intValue(); // 언박싱
```
- 박싱 : 기본 타입의 값을 포장 객체로 만드는 과정
- 언박싱 : 포장 객체를 기본 타입의 값을 얻어내는 과정

```java
@Deprecated(since="9", forRemoval = true)  
public Integer(int value) {  
    this.value = value;  
}
```
자바 9버전 부터 `@Deprecated`

## AutoBoxing과 AutoUnBoxing

```java
Integer num1 = 123; // 자동 박싱
int num2 = num1; //자동 언박싱
```

위와 같이 박싱과 언박싱이 자동으로 발생하기 때문이다.