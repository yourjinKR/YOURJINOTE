### 역할과 구현 분리

자바 프로그래밍에서 역할은 어떤 객체가 수행해야 할 행위를 정의하는 것이고 구현은 각각의 행위가 어떤 로직으로 동작되는지 설계하는 것입니다.

예를 들어 결제 모듈을 개발한다고 할때 카드, 간편결제, 계좌이체 등 다양한 결제방식이 있으며 이를 `Payments`라는 인터페이스를 정의하여 역할을 부여하고 `CardPayments`, `BankPayments`, `EasyPayments` 으로 구현체를 만들어 관리하는 과정입니다.

### 불변 객체의 중요성

- 멀티 스레딩 환경에서 유리하다 → 별도의 동기화 없어도 안전함
- 사이드 이펙트 최소화, 값이 변경되지 않기에 예기치 않는 상태의 변화가 없음 → 안정성 확보 가능

### static

static으로 정적 데이터 선언 → Class가 로드될때 Method Area에 저장 → 프로그램이 종료될때까지 메모리에 할당

### final

final은 재할당을 막는 키워드입니다.  
변수에 선언시 재할당을 불가능하게 합니다.  
클래스에 선언시 상속할 수 없습니다.  
메서드에 선언시 오버라이드 할 수 없습니다.  

### String, StringBuilder, StringBuffer의 차이(불변 객체)를 설명할 수 있다

자바에서는 문자열을 데이터 캐싱, 동기화, 보안 등의 이슈로 인해 불변으로 설계 했습니다.  
그로 인해 

### equals와 hashcode

equals와 hashcode는 논리적 동등성을 보장하기 위해서 사용됩니다.  
equals == true, hashcode.equals(hashcode)
but, hashCode == hashCode, equals != true 일수도 있음. → 이를 해시 충돌.  
equals 재정의시 hashCode 또한 재정의 필요

### 오토박싱 / 언박싱

오토박싱은 Wrapper Class 생성시 원시 타입으로 바로 생성할 수 있는 것이다.  
언박싱은 Wrapper Class의 값을 원시 타입에 바로 할당 할 수 있는 것을 말합니다.

Wrapper Class와 같은 경우는 nullable 하지만 오버헤드가 있기에 null이 아니며 단순 반복 같은 작업에서 사용되면 굳이 사용하지 않는 것이 좋습니다.

### Wrapper 간 객체 비교

wrapper 타입은 비교시에는 equals를 사용해야 함.

### enum

enum은 연관된 상수들의 집합을 정의할 때 사용함.  
컴파일 시점에 강력한 타입 안정성을 보장함.  

### List Set Map의 차이를 설명 가능

List는 순서와 중복을 허용하는 컬렉션  
Set는 순서 보장 X, 중복 허용 X  
Map은 key-value쌍의 데이터 구조를 가짐, key는 중복 X, value는 중복 가능, 일반적으로 순서를 보장X

### ArrayList, LinkedList

arrayList : 배열 기반, 인덱스 기반으로 데이터 조회 성능 우수, 베열의 길이가 고정이기에 크기가 커지면 새로 생성 후 기존 데이터를 복사하는 비용 발생, 오버헤드가 적음
linkedList : 노드 참조 기반, 조회시 참조를 따라가며 찾기에 성능이 좋지 않음, 특정 위치만 알고 있다면 데이터 추가/삭제는 유리함 → 이전 노드와 다음 노드 사이에 쏙 넣으면 돼서, 참조 변수를 위한 메모리 공간이 필요함
