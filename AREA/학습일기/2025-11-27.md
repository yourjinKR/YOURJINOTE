- [ ] 유저 도메인 고민해보기
- [x] 자바 장단점+
- [x] 코테 풀이
- [x] 김은서 프로젝트 후기 작성

---

# 기초개념 공부

[객체지향 프로그래밍 복습](https://github.com/yourjinKR/YOURJINOTE/blob/3451075e067fdac9816cf7db0d6a342049e53556/RESOURCE/CS/OOP%20\(%EA%B0%9D%EC%B2%B4%20%EC%A7%80%ED%96%A5%20%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D\).md)  
[JVM 클래스 로더](https://github.com/yourjinKR/YOURJINOTE/blob/3451075e067fdac9816cf7db0d6a342049e53556/RESOURCE/CS/%ED%81%B4%EB%9E%98%EC%8A%A4%20%EB%A1%9C%EB%8D%94%20\(Class%20Loader\).md)

# 코테 풀이

[백준 조건문 단계별 풀이](https://github.com/yourjinKR/javaBasic/commit/63133d97d00ff50768a3f0bb727301152438f76a)

# 개인 프로젝트

[PR 링크](https://github.com/yourjinKR/fitsync2-backend/pull/3)  
[JPA 임베디드 타입](https://github.com/yourjinKR/YOURJINOTE/blob/3451075e067fdac9816cf7db0d6a342049e53556/RESOURCE/JPA/%5BJPA%5D%20%EC%9E%84%EB%B2%A0%EB%94%94%EB%93%9C%20%ED%83%80%EC%9E%85\(embedded%20type\).md)

## 프로젝트를 초기화

국비교욱 후 10월말까지 조금씩 fitsync2 개발을 진행했었다.  
그러나 지금 현재 다시 갈아 엎었다.

> **갈아 엎는 이유**  
> 새로운 기술을 배우지 않으면 도태된다는 강박증에 타입스크립트, 리액트,  
> CI/CD, AWS를 통한 배포 등 새롭게 배우는 기술을 한번에 적용했었다.
> 
> 이 과정에서 AI가 만들어준 코드가 굉장히 많았기에  
> 로직에 대한 이해가 너무나 부족했고 리팩토링시 어려움을 느꼈다.
> 
> 이번에는 AI 사용을 최소화하여 다시 개발을 시작하고자 한다.
> 
> 일단 프로젝트에서 지금 집중할건 **JPA**와 **mysql**

해당 프로젝트를 수행하는 목적은 기존의 기능들을 개선하고 배포를 경험하고 싶기 때문이다.  
그렇다면 일단 운동기록, 루틴작성, AI 추천기능까지만 구현할 것이다.

### 시큐리티를 언제 구현할까?

시큐리티(인증/인가 + 소셜로그인)를 언제할지 잘 모르겠다.

- 시큐리티 구현 -> API 구현
- API 구현 -> 시큐리티 구현

배포를 일단 1차적으로 만든 후 천천히 알아보면서 진행할 예정이기에 이번엔 CI/CD가 없다. 그렇다면 시큐리티를 먼저 구현할 필요가 있을까?

> 시큐리티를 후순위로 두자

### API 구현 순서

- 유저 간단한 CRUD
- 운동정보 CRUD
- 루틴 CRUD
- 운동기록 CRUD
- AI 서비스  
    - 루틴 추천 서비스  
    - 운동 피드백 서비스


---



# fitsync2 개발

## feat: 유저 정보에 성별과 이름을 추가 #3
[PR link](https://github.com/yourjinKR/fitsync2-backend/pull/3)

### 성별은 enum으로 관리
```java
public enum Gender {  
    MALE,  
    FEMALE  
}
```

### 생년월일을 별개의 객체로 관리
```java
import jakarta.persistence.Embeddable;  
import java.time.LocalDateTime;  
import java.time.temporal.ChronoUnit;  
import lombok.NoArgsConstructor;  
  
@Embeddable  
@NoArgsConstructor  
public class BirthDate {  
    public static BirthDate EMPTY = new BirthDate(null);  
    private LocalDateTime birth;  
  
    public BirthDate(LocalDateTime localDateTime) {  
        this.birth = localDateTime;  
    }  
  
    public Long getAge() {  
        LocalDateTime now = LocalDateTime.now();  
        return ChronoUnit.YEARS.between(birth, now);  
    }  
}
```

```java
static BirthDate toBirthDate(BirthReqeust reqeust) {  
    if (reqeust == null) { return BirthDate.EMPTY; }  
  
    LocalDateTime birth = LocalDateTime.of(  
            reqeust.year(),  
            reqeust.month(),  
            reqeust.dayOfMonth(),  
            0,  
            0  
    );  
  
    return new BirthDate(birth);  
}
```
객체는 위와 같이 생성함

---

# 운동정보
```java
@Entity  
@Table(name = "exercises")  
public class Exercise extends BaseEntity {  
  
    @Id  
    @GeneratedValue(strategy = GenerationType.IDENTITY)  
    private Long id;  
  
    @Column(name = "name")  
    private String name;  
  
    @Column(name = "category")  
    private String category;  
  
    @Column(name = "description")  
    private String description;  
  
    @JdbcTypeCode(SqlTypes.JSON)  
    @Column(name = "details", columnDefinition = "json")  
    private Map<String, Object> details;  
  
    @Column(name = "hidden")  
    private boolean hidden = false;  
}
```

처음에 `category`에 운동 자극 부위를 기입하려고 했다.
그러나 추후에 운동정보에 피트니스 뿐만 아니라 다양한 운동정보(크로스핏, 요가)를 지원하고 싶기에 `category`는 자극부위가 아닌 앞서 언급한 운동정보에 해당될것이다.

그렇다면 자극부위와 카테고리를 따로 관리할 필요가 있다
각각의 이름을 추천

해당 개념은 도메인 지식이 부족하기에 gpt에게 도움을 받았다.

좋습니다. 지금 말씀하신 구조를 보면 **운동 정보를 AI 추천까지 고려해서 체계적으로 설계하려면 계층적 구조 + 범용 엔티티 모델이 필요**합니다. 하나씩 풀어보겠습니다.

---

# 1️⃣ 고려해야 하는 계층

1. **대분류(카테고리)**
    
    - 운동의 장르/종류
        
    - 예: 헬스, 요가, 크로스핏
        
    - Enum 또는 테이블로 관리 가능
        
2. **효과(Effect)**
    
    - 운동이 겨냥하는 목표/대상
        
    - 근육(MUSCLE), 관절(JOINT), 심폐(CARDIO), 지구력(ENDURANCE) 등
        
    - EffectType으로 분류
        
    - **여기서 근육/관절/심폐 등은 통합**
        
3. **부위(BodyPart)**
    
    - 효과가 적용되는 신체 부위
        
    - 예: 어깨, 등, 팔, 복근, 고관절
        
    - 부위 별로 **계층 구조 가능**
        
4. **세부 부위(SubBodyPart / MuscleDetail)**
    
    - 특정 부위 내 세분화
        
    - 예: 어깨 → 전면/측면/후면 어깨
        
    - AI가 루틴 추천 시 특정 세부 부위까지 선택 가능
        
    - 계층형(Parent-Child) 구조
        

---

# 2️⃣ 계층적 구조 설계

```
Exercise
 ├─ Category (대분류)
 ├─ ExerciseEffect (운동 ↔ Effect 관계)
      ├─ Effect (근육, 관절, 심폐 등)
           └─ BodyPart (등, 어깨, 팔)
                └─ SubBodyPart (전면 어깨, 후면 어깨, 측면 어깨)
```

---

# 3️⃣ JPA 설계 예시

### 3-1) Category

```java
public enum ExerciseCategory {
    FITNESS,
    CROSSFIT,
    YOGA,
    PILATES,
    REHAB
}
```

---

### 3-2) Effect

```java
@Entity
@Table(name = "effects")
public class Effect {

    @Id @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Enumerated(EnumType.STRING)
    @Column(nullable = false)
    private EffectType type; // MUSCLE, JOINT, CARDIO, ENDURANCE

    @Column(nullable = false)
    private String name; // 근육명, 관절명, 심폐 등

    @OneToMany(mappedBy = "effect")
    private Set<BodyPart> bodyParts = new HashSet<>();
}
```

---

### 3-3) BodyPart

```java
@Entity
@Table(name = "body_parts")
public class BodyPart {

    @Id @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(nullable = false)
    private String name; // 등, 어깨, 팔, 복근

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "effect_id")
    private Effect effect;

    @OneToMany(mappedBy = "parent")
    private Set<SubBodyPart> subParts = new HashSet<>();
}
```

---

### 3-4) SubBodyPart

```java
@Entity
@Table(name = "sub_body_parts")
public class SubBodyPart {

    @Id @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(nullable = false)
    private String name; // 전면 어깨, 후면 어깨, 측면 어깨

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "body_part_id")
    private BodyPart parent;
}
```

---

### 3-5) ExerciseEffect (운동 ↔ 효과 관계)

```java
@Entity
@Table(name = "exercise_effects")
public class ExerciseEffect {

    @Id @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @ManyToOne(fetch = FetchType.LAZY)
    private Exercise exercise;

    @ManyToOne(fetch = FetchType.LAZY)
    private Effect effect;

    @ManyToMany
    @JoinTable(
        name = "exercise_sub_body_parts",
        joinColumns = @JoinColumn(name = "exercise_effect_id"),
        inverseJoinColumns = @JoinColumn(name = "sub_body_part_id")
    )
    private Set<SubBodyPart> subBodyParts = new HashSet<>();

    @Enumerated(EnumType.STRING)
    private EffectRole role; // PRIMARY, SECONDARY
}
```

---

# 4️⃣ 설계 특징

1. **계층 구조**
    
    - `Effect` → `BodyPart` → `SubBodyPart`
        
    - AI 추천 시 “어깨 전체” → “전면/후면/측면 선택 가능”
        
2. **통합 모델**
    
    - 근육, 관절, 심폐, 지구력 등 모든 효과를 `Effect` 하나로 통합
        
    - 검색과 확장 용이
        
3. **관계 확장성**
    
    - Exercise ↔ Effect ↔ SubBodyPart
        
    - 다대다 관계로 여러 부위 동시 표현 가능
        
4. **AI 추천 대응**
    
    - AI가 “어깨 운동 루틴” 추천 시
        
        - `SubBodyPart`까지 고려 → “전면/후면/측면 균형 있게” 선택 가능
            

---

# 5️⃣ 예시 데이터 구조

|Exercise|Effect Type|Effect Name|BodyPart|SubBodyPart|Role|
|---|---|---|---|---|---|
|벤치프레스|MUSCLE|근육|어깨|전면 어깨|SECONDARY|
|벤치프레스|MUSCLE|근육|가슴|-|PRIMARY|
|숄더 프레스|MUSCLE|근육|어깨|측면 어깨|PRIMARY|
|런지|JOINT|관절|고관절|-|PRIMARY|
|러닝|CARDIO|심폐|-|-|PRIMARY|

---

# 6️⃣ 요약 추천 구조

|계층|필드명/엔티티|내용|
|---|---|---|
|대분류|Category|FITNESS, CROSSFIT, YOGA|
|효과|Effect|근육, 관절, 심폐, 지구력 등|
|부위|BodyPart|등, 어깨, 팔, 복근, 고관절|
|세부부위|SubBodyPart|전면 어깨, 후면 어깨, 측면 어깨|
|운동 ↔ 효과|ExerciseEffect|role, intensity 등 속성 포함|

---

원하시면 제가 이 구조 기준으로 **완전한 JPA 엔티티 + DDL 스키마 + 샘플 데이터 10~20개**까지 만들어 드릴 수 있습니다.  
바로 만들어 드릴까요?