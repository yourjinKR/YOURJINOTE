- [ ] Thread란?
- [ ] 불변성과 가변성, 그리고 thread-safe
- [ ] Java에서 지원하는 Date와 Time
	- https://gngsn.tistory.com/169#google_vignette
- [x] jvm oop 강의
	- [x] 객체, 클래스, 인스턴스, this, 생성자
- [x] 자바의 장단점 ++ 
	- [x] 자바가 경제적인 이유?
	- [x] 순수 자바 빌드 실습
	- [x] 소프트웨어 이식성
	- [x] 가비지 컬렉터
- [x] 백준 문제풀이
- [x] 개인 프로젝트

---

# 기초 개념 공부
[자바가 경제적인 이유](https://github.com/yourjinKR/YOURJINOTE/commit/16cc55e87b976c9098793abedb052942841feebc#diff-69870a0bc2916457e5ffaee978368564297525872c0320d79cb324ecb7d91d3b)
[소프트웨어 이식성](https://github.com/yourjinKR/YOURJINOTE/blob/16cc55e87b976c9098793abedb052942841feebc/RESOURCE/CS/%EC%86%8C%ED%94%84%ED%8A%B8%EC%9B%A8%EC%96%B4%20%EC%9D%B4%EC%8B%9D%EC%84%B1%20(software%20portability).md)
[순수 자바 파일을 빌드툴 없이 빌드하기](https://github.com/yourjinKR/YOURJINOTE/blob/16cc55e87b976c9098793abedb052942841feebc/RESOURCE/JAVA/%5BJava%20%EC%8B%A4%EC%8A%B5%5D%20%EC%88%9C%EC%88%98%20%EC%9E%90%EB%B0%94%20%ED%8C%8C%EC%9D%BC%EB%93%A4%EC%9D%84%20%EB%B9%8C%EB%93%9C%ED%88%B4%20%EC%97%86%EC%9D%B4%20%EB%B9%8C%EB%93%9C%20%ED%95%B4%EB%B3%B4%EA%B8%B0.md)
[가비지 컬렉션](https://github.com/yourjinKR/YOURJINOTE/blob/16cc55e87b976c9098793abedb052942841feebc/RESOURCE/JAVA/%5BJava%5D%20%EA%B0%80%EB%B9%84%EC%A7%80%20%EC%BB%AC%EB%A0%89%EC%85%98%20(Garbage%20Collection).md)

> 인프런에 1000원짜리 OOP & JVM 수업이 열려서 유용하게 듣고 있다.
[기초 탄탄! 독하게 시작하는 Java - Part 2 : OOP와 JVM](https://www.inflearn.com/course/%EB%8F%85%ED%95%98%EA%B2%8C-%EC%8B%9C%EC%9E%91%ED%95%98%EB%8A%94-java-part2/dashboard)

# 코테 풀이
[백준 단계별 문제 풀이 1~6](https://github.com/yourjinKR/javaBasic/commit/311705335f1b55a216544b9ce6d4db9d8df44930)
# 개인 프로젝트
[PR link](https://github.com/yourjinKR/fitsync2-backend/pull/4)
## 작업 내용
- 운동 정보 생성 API 구현
- 운동 정보 생성 API Service Layer 테스트

## 배운 점
- `.gitkeep`을 활용하여 빈 디렉토리를 commit에 남길 수 있다.
- 서비스 레이어에서 테스트할 때 `mockito`를 사용해보자.
- 빌더를 사용할땐 모든 값이 초기화되야 한다.
- `@RequiredArgsConstructor`를 사용할땐 `final`를 명시하자.



---

# Java - Part 2 : OOP와 JVM

# OT
jvm은 native하지만 결국은 OS를 얘기할 수 밖에 없다.
### 학습 목표

---

# 객체(Object)란?
- OOP 환경에서 소프트웨어를 구성하는 단위 요소
- 변수 및 그와 관련한 메서드가 모여서 이뤄진 하나의 집합체
	- **클래스는 반드시 존재 이유와 목적이 명확해야 함**
- 자바에서는 클래스(Class)로 객체를 기술
## 부연설명
- 무엇을 객체로 기술할 것인가? <- 정답이 없음, 엄청난 논쟁점이다.
- 설계 -> 디자인 패턴
> OOP에서 설계는 "무엇을 객체로 기술할 것"인가 이다.
- 프로그램 = Object의 집합체 + 관계

+ 객체는 하드웨어단에서는 없는 개념이므로 객체를 다루는건 고급언어

# 클래스, 객체, 인스턴스
**클래스는 변수와 같은 자료형으로 이해**
- 클래스는 객체를 기술하는 문법
- 클래스 형식에 대해 선언 할 수 있는 것은 참조(null 가능)
**사전적 의미는 "예시" 혹은 "경우"**
**변수 대신 인스턴스라고 표현**
- int 형식에 대한 인스턴스 a
**다양하게 사용되는 용어**
- 프로세스 인스턴스
## 클래스 기본 문법
```java
class 클래스명 { }
```
- 관계에 대해 생각하지 않는다면 함수를 구성요소로 포함하는 집합체로 이해
- 구성요소를 멤버라 지칭
	- 변수는 필드, 함수는 메서드
	- 변수는 메모리를 사용하는 보편적인 수단
- 선언과 정의가 공존하는 구조
> 객체 작성자와 사용자를 구분해 생각하는 능력이 중요하다
### 클래스명 컨벤션
- 클래스 이름은 영문으로 작성하되 첫 글자는 대문자로 작성하는 것이 보편적인 규칙이다.
### 클래스명 규칙
- 클래스 이름과 저장되는 .java 파일명이 같아야 한다.

## 클래스 기본 구성
### 패키지
폴더 형태로 존재
### 클래스
.java 파일 형태로 존재

![Pasted image 20251128150945](Pasted%20image%2020251128150945.png)

## 참고 사항
항, 식, 구문이 있는데 여러 구문들을 묶어서 사용하는 것이 **함수(메서드)**이다.
![Pasted image 20251128144820](Pasted%20image%2020251128144820.png)

# 생성자와 필드 초기화
## 멤버 선언 및 초기화
- 필드 선언 시 초깃값 정의 가능 
	- 초깃값을 기술하지 않을 경우 기본 값은 0
## 생성자를 통해 초기화 가능 
- 필드 선언 시 기술한 초깃값과 생성자에서 정의하는 값이 서로 다를 경우 **생성자에 기술한 코드가 우선**

인스턴스를 저장하기 위해서는 메모리가 필요한데 JVM에서 메모리 공간은 크게 두가지 종류가 있다.
1. 스택
2. 힙
### 스택 (Stack)
지역변수, 자동변수는 스택에 저장
### 힙 (Heap)
인스턴스를 저장
### new 연산자
해당 연산자의 본질은 특정 클래스의 인스턴스를 동적 생성하는 것이다.
> 동적 (Dynamic = Runtime) 

### 생성자
- 생성자는 객체가 생성되는 시점에 자동으로 호출되는 **메서드**
	- 생성자명 == 클래스명
	- 생략시 컴파일러가 빈 생성잘르 자동으로 추가
	- 반환자료와 호출자가 없다는 점에 유의
- 객체의 생성은 new 연산에 따른 동적 생성
- 다중 정의 가능
- **클래스 자체와 관련된 코드만 기술할 것**
> 이전에 클래스의 생성자에 Validation과 같은 유틸함수를 포함시켰는데 이는 좋지 않은건가?

### 인스턴스 동적 생성
- new 연산자를 이용해 인스턴스 동적 생성 (Heap 영역에 저장)
- 클래스 형식에 대한 변수 선언은 모두 참조
	- 인스턴스가 존재하지 않는 경우는 `null`
- 인스턴스에 대해 여러 참조가 있을 수 있다.
	- 사이드 이펙트 문제 고려

# 클래스 멤버에 대한 접근 제어
- private
- protected
- default
- public
> 프로그램의 구성 요소를 간략화하여 추상화를 실현 가능
## getter()와 setter()
- private로 선언된 필드를 외부에서 접근 할 수 있도록 허용된 메서드
# this
- 클레스로 구현한 객체 자신의 인스턴스에 대한 참조자
- 클래스(현재 코드)에 대한 인스턴스(미래, 외부) 선언 시 값이 결정될 수 있음
- 같은 클래스에 대한 인스턴스더라도 this 값은 각자 다르다
- 메서드 호츨 시 스택 (0번 슬롯)에 값이 저장
- 정적 메서드에서는 사용할 수 없음

---

# Exercise(운동정보) 엔티티 모델링

운동 데이터는 운동명과 설명 뿐만 아니라 많은 정보를 제공해야 된다.

- 해당 운동이 어떤 종류인가? (헬스, 요가, 필라테스...)
- 해당 운동은 어떤 효과를 주는가? (근육, 관절, 심폐, 지구력)
- 해당 운동은 어떤 부위를 자극하는가? (가슴, 팔, 등, 어깨, 고관절)
- 부위를 세분화하여 나누어야 하는가? (전면 어깨, 측면 어깨...)

> 하나의 운동이 여러 속성을 지닐 수 있을까?


> 해당 내용은 고정값이니 모든 데이터를 enum으로 관리하면 될까?

## 다중 속성 여부 고려
카테고리(대분류)를 제외하고는 모든 속성이 중복될 수 있음.
그러기에 카테고리는 enum으로 관리하고 나머지는 테이블 연관관계로 구현해야 할듯



# 제미나이에게 질문

너가 추천한 내용 중 적용시키려고 하는 분야는 다음과 같음. 이름도 살짝 변경했어

- ExerciseCategory : 운동 카테고리 (enum으로 관리)
- BodyPart : 신체 부위
- BodyDetailPart : 신체 세부 부위
- EffectType : 운동 효과 유형

카테고리는 다중 속성이 불가능하니 enum으로 관리하고 나머지는 별도의 테이블로 관리해보자.
그러나 해당 속성들은 조금 고정적인 성격을 갖고 있으니 읽기 전용으로 디자인하는게 좋을거 같음.




현재 Java기반 Spring Boot + JPA + MySQL 기반의 프로젝트 중임.
데이터 모델링 하는데 너의 도움이 필요해.

운동기록 서비스를 만들 예정이며 현재 Exercise(운동 정보)는 다음과 같이 구현했음.

```java
package app.fitsync.domain.exercise.entity;  
  
import app.fitsync.global.BaseEntity;  
import jakarta.persistence.Column;  
import jakarta.persistence.Entity;  
import jakarta.persistence.EnumType;  
import jakarta.persistence.Enumerated;  
import jakarta.persistence.GeneratedValue;  
import jakarta.persistence.GenerationType;  
import jakarta.persistence.Id;  
import jakarta.persistence.Table;  
import java.util.Map;  
import org.hibernate.annotations.JdbcTypeCode;  
import org.hibernate.type.SqlTypes;  
  
@Entity  
@Table(name = "exercises")  
public class Exercise extends BaseEntity {  
  
    @Id  
    @GeneratedValue(strategy = GenerationType.IDENTITY)  
    private Long id;  
  
    @Column(name = "name")  
    private String name;  
  
    @Column(name = "category")  
    @Enumerated(EnumType.STRING)  
    private ExerciseCategory category;  
  
    @Column(name = "description")  
    private String description;  
  
    @JdbcTypeCode(SqlTypes.JSON)  
    @Column(name = "details", columnDefinition = "json")  
    private Map<String, Object> details;  
  
    @Column(name = "hidden")  
    private boolean hidden = false;  
}
```

```java
package app.fitsync.domain.exercise.entity;

/**
 * 운동 카테고리 (대분류)
 */
public enum ExerciseCategory {
    /**
     * 헬스, 근력 중심 운동
     */
    FITNESS,

    /**
     * 크로스핏
     */
    CROSSFIT,

    /**
     * 요가
     */
    YOGA,

    /**
     * 필라테스
     */
    PILATES,

    /**
     * 재활, 물리치료용 운동
     */
    REHAB
}

```

이때 운동 정보에 추가적인 속성들과 연관관계를 구성해야 함.

- BodyPart : 신체 부위 (어깨, 가슴, 등...)
- BodyDetailPart : 신체 세부 부위 (후면 어깨, 전면 어깨, 측면 어깨, 이두, 삼두...)
- EffectType : 운동 효과 유형 (근력, 지구력, 심폐, 고관절, 유연성)

해당 속성들은 하나의 운동정보가 중복으로 가질 수 있음.
(예시 : 하나의 운동이 어깨와 가슴을 자극할 수 있기에)




# @ElementCollection
![Pasted image 20251128205137](Pasted%20image%2020251128205137.png)

```java
@ElementCollection(targetClass = EffectType.class)  
@CollectionTable(  
        name = "exercise_effects",  
        joinColumns = @JoinColumn(name = "exercise_id")  
)  
@Enumerated(EnumType.STRING)  
@Column(name = "effect_type")  
private Set<EffectType> effects = new HashSet<>();
```

![Pasted image 20251128220239](Pasted%20image%2020251128220239.png)

https://www.youtube.com/watch?v=lQ4-kVeHVGk
