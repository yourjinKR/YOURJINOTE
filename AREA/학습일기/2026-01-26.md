

### 요구사항

- 서비스 코드 테스트 코드 작성 필요
- 현재 테스트 코드 작성에 익숙치 않음으로 수준을 고려한 코드 작성
- 더 정확한 테스트 코드 작성을 위해 다른 파일의 코드가 궁금하다면 추가 요청 가능

### service code

```java
package app.fitsync.domain.ai.service;  
  
import app.fitsync.domain.ai.dto.AIRoutineRequest;  
import app.fitsync.domain.ai.dto.AIRoutineResponse;  
import app.fitsync.domain.ai.dto.RoutineRecommendUserMessage;  
import app.fitsync.domain.ai.entity.AIModel;  
import app.fitsync.domain.ai.entity.OpenAIPromptGenerator;  
import app.fitsync.domain.ai.mapper.AILogMapper;  
import app.fitsync.domain.exercise.mapper.ExerciseMapper;  
import app.fitsync.domain.exercise.repository.ExerciseRepository;  
import app.fitsync.domain.profile.entity.UserProfile;  
import app.fitsync.domain.profile.exception.UserProfileException;  
import app.fitsync.domain.profile.repository.UserProfileRepository;  
import app.fitsync.global.exception.RestApiException;  
import com.fasterxml.jackson.core.JsonProcessingException;  
import com.fasterxml.jackson.databind.ObjectMapper;  
import java.util.HashMap;  
import java.util.Map;  
import java.util.UUID;  
import lombok.RequiredArgsConstructor;  
import org.springframework.ai.chat.client.ChatClient;  
import org.springframework.ai.chat.metadata.Usage;  
import org.springframework.ai.chat.model.ChatResponse;  
import org.springframework.ai.chat.prompt.Prompt;  
import org.springframework.ai.openai.OpenAiChatOptions;  
import org.springframework.ai.openai.api.ResponseFormat;  
import org.springframework.stereotype.Service;  
  
@Service  
@RequiredArgsConstructor  
public class OpenAIService implements AIServiceInterface {  
  
    private final ExerciseRepository exerciseRepository;  
    private final UserProfileRepository userProfileRepository;  
    private final ExerciseMapper exerciseMapper;  
    private final AILogWriter aiLogWriter;  
    private final ObjectMapper objectMapper = new ObjectMapper();  
    private final ChatClient chatClient;  
    private final AILogMapper aiLogMapper;  
  
    /*  
  
    TODO: 로직 관심사에 따른 분리 리팩토링 여부에 대해 고민 (프롬프트 생성, API 요청, 로깅)  
  
    1. request로부터 요청에 필요한 값들을 받아 프로필 조회    2. 유저 기록을 기반으로 프롬프트 생성 (유저 메세지)    3. 메세지 객체 생성    4. 로그 작성 (대기 상태)    // try catch 시작    5. 옵션 빌더를 통해 옵션 생성    6. 응답 받은 ChatResponse 내부의 메타 데이터를 기반으로 추가 로그 정보 작성 // 성공시, 토큰  
     */    @Override  
    public AIRoutineResponse generateRoutine(AIRoutineRequest request) throws JsonProcessingException {  
  
        String requestId = UUID.randomUUID().toString();  
  
        long userId = request.userId();  
  
        UserProfile profile = userProfileRepository.findByUserId(userId)  
                .orElseThrow(() -> new RestApiException(UserProfileException.NOT_FOUND, userId));  
  
        RoutineRecommendUserMessage userMessageRequest = aiLogMapper.toDto(profile, request);  
        OpenAIPromptGenerator openAIPromptGenerator = OpenAIPromptGenerator.routineRecommendOf(userMessageRequest);  
  
        aiLogWriter.init(  
                requestId,  
                userId,  
                AIModel.GPT_4_1_MINI,  
                "ROUTINE_RECOMMEND",  
                "0.0.1",  
                openAIPromptGenerator.getInputJsonOf()  
        );  
  
        Long inputTokens = null;  
        Long outputTokens = null;  
  
        try {  
            OpenAiChatOptions options = OpenAiChatOptions.builder()  
                    .model(AIModel.GPT_4_1_MINI.getName())  
                    .temperature(0.7)  
                    .responseFormat(  
                            ResponseFormat.builder()  
                                    .type(ResponseFormat.Type.JSON_OBJECT)  
                                    .build()  
                    )  
                    .build();  
  
            Prompt prompt = new Prompt(openAIPromptGenerator.getListOf(), options);  
  
            ChatResponse response = chatClient.prompt(prompt)  
                    .tools(new AITools(exerciseRepository, exerciseMapper))  
                    .call()  
                    .chatResponse();  
  
            assert response != null;  
                Usage usage = response.getMetadata().getUsage();  
  
            inputTokens  = Long.valueOf(usage.getPromptTokens());  
            outputTokens = Long.valueOf(usage.getCompletionTokens());  
  
            String content = response.getResult().getOutput().getText();  
            AIRoutineResponse result =  
                    objectMapper.readValue(content, AIRoutineResponse.class);  
  
            Map<String, Object> outputJson = new HashMap<>();  
            outputJson.put("result", result);  
  
            aiLogWriter.success(  
                    requestId,  
                    outputJson,  
                    inputTokens,  
                    outputTokens  
            );  
  
            return result;  
  
        } catch (Exception e) {  
            aiLogWriter.failure(requestId, inputTokens, e.getMessage());  
            throw e;  
        }  
    }  
}
```

### test class

```java
package app.fitsync.domain.ai.service;  
  
import static org.assertj.core.api.Assertions.*;  
  
class OpenAIServiceTest {  
  
}
```

## ChatResult 없음 

`org.springframework.ai.chat.model.ChatResult`는 존재하지 않음.

```groovy
plugins {  
    id 'java'  
    id 'org.springframework.boot' version '3.5.9'  
    id 'io.spring.dependency-management' version '1.1.7'  
}  
  
group = 'app'  
version = '0.0.1-SNAPSHOT'  
description = 'backend'  
  
java {  
    toolchain {  
        languageVersion = JavaLanguageVersion.of(21)  
    }  
}  
  
configurations {  
    compileOnly {  
        extendsFrom annotationProcessor  
    }  
}  
  
repositories {  
    mavenCentral()  
}  
  
ext {  
    set('queryDslVersion', "5.0.0")  
    set('springAiVersion', "1.1.2")  
}  
  
dependencies {  
    implementation 'org.springframework.boot:spring-boot-starter-data-jpa'  
    implementation 'org.springframework.boot:spring-boot-starter-thymeleaf'  
    implementation 'org.springframework.boot:spring-boot-starter-validation'  
    implementation 'org.springframework.boot:spring-boot-starter-web'  
    compileOnly 'org.projectlombok:lombok'  
    developmentOnly 'org.springframework.boot:spring-boot-devtools'  
    runtimeOnly 'com.mysql:mysql-connector-j'  
    annotationProcessor 'org.projectlombok:lombok'  
    testImplementation 'org.springframework.boot:spring-boot-starter-test'  
    testImplementation 'org.mockito:mockito-inline:5.2.0'  
    testImplementation group: 'org.assertj', name: 'assertj-core', version: '3.21.0'  
    testRuntimeOnly 'org.junit.platform:junit-platform-launcher'  
  
    implementation "com.querydsl:querydsl-jpa:${queryDslVersion}:jakarta"  
    annotationProcessor "com.querydsl:querydsl-apt:${queryDslVersion}:jakarta"  
    annotationProcessor "jakarta.annotation:jakarta.annotation-api"  
    annotationProcessor "jakarta.persistence:jakarta.persistence-api"  
  
    implementation 'org.jspecify:jspecify:1.0.0'  
  
    // Spring AI  
    implementation 'org.springframework.ai:spring-ai-starter-model-openai'  
}  
  
dependencyManagement {  
    imports {  
        mavenBom "org.springframework.ai:spring-ai-bom:${springAiVersion}"  
    }  
}  
  
// 1. Q-Class를 생성할 디렉토리 경로를 설정합니다.  
def queryDslSrcDir = 'src/main/generated/querydsl/'  
  
// 2. JavaCompile Task를 수행하는 경우 생성될 소스코드의 출력 디렉토리를 queryDslSrcDir로 설정합니다.  
tasks.withType(JavaCompile).configureEach {  
    options.getGeneratedSourceOutputDirectory().set(file(queryDslSrcDir))  
}  
  
// 3. 소스 코드로 인식할 디렉토리에 경로에 Q-Class 파일을 추가합니다. 이렇게 하면 Q-Class가 일반 Java 클래스처럼 취급되어 컴파일과 실행 시 클래스패스에 포함됩니다.  
sourceSets {  
    main.java.srcDirs += [queryDslSrcDir]  
}  
  
// 4. clean Task를 수행하는 경우 지정한 디렉토리를 삭제하도록 설정합니다. : 자동 생성된 Q-Class를 제거합니다.  
clean {  
    delete file(queryDslSrcDir)  
}  
  
configurations {  
    compileOnly {  
        extendsFrom annotationProcessor  
    }  
    // 5. QueryDSL과 관련된 라이브러리들이 컴파일 시점에만 필요하도록 설정합니다. 또한, QueryDSL 설정을 컴파일 클래스패스에 추가합니다.  
    querydsl.extendsFrom compileClasspath  
}  
  
tasks.named('test') {  
    useJUnitPlatform()  
}
```

## 테스트 코드 실행 경고문

![Pasted image 20260126163115](GALLERY/Pasted%20image%2020260126163115.png)

테스트 코드 메서드 하나 실행했는데 경고문 발생함

> 21 이상의 JDK에서 지원하지 않는 기능이기에 경고

## AiLogWriter 테스팅

`init` 메서드 실행시 상태와 상태 메세지를 `null`로 저장할 것임.  
테스트 코드 작성 및 작성바람.

### Test

```java
package app.fitsync.domain.ai.service;  
  
import static org.assertj.core.api.Assertions.*;  
  
import org.junit.jupiter.api.DisplayName;  
import org.junit.jupiter.api.Test;  
  
class AILogWriterTest {  
  
    @Test  
    @DisplayName("초기화시 log의 상태와 상태 메세지는 null임")  
    public void initLogId() {  
  
    }  
  
  
}
```

### AILogWriter

```java
package app.fitsync.domain.ai.service;  
  
import app.fitsync.domain.ai.entity.AILog;  
import app.fitsync.domain.ai.entity.AIModel;  
import app.fitsync.domain.ai.entity.CallStatus;  
import app.fitsync.domain.ai.exception.AILogErrorCode;  
import app.fitsync.domain.ai.repository.AILogRepository;  
import app.fitsync.global.exception.RestApiException;  
import java.time.LocalDateTime;  
import java.util.Map;  
import lombok.RequiredArgsConstructor;  
import org.springframework.stereotype.Component;  
import org.springframework.transaction.annotation.Transactional;  
  
@Component  
@RequiredArgsConstructor  
public class AILogWriter {  
  
    private final AILogRepository repository;  
  
    @Transactional  
    public void init(  
            String requestId,  
            Long userId,  
            AIModel model,  
            String feature,  
            String version,  
            Map<String, Object> inputContent) {  
  
        AILog log = AILog.builder()  
                .requestId(requestId)  
                .userId(userId)  
                .model(model)  
                .feature(feature)  
                .version(version)  
                .inputContent(inputContent)  
                .requestTime(LocalDateTime.now())  
//                .status(CallStatus.SUCCESS)  
//                .statusMessage("pending")  
                .build();  
  
        repository.save(log);  
    }  
  
    @Transactional  
    public void success(  
            String requestId,  
            Map<String, Object> outputContent,  
            Long inputTokens,  
            Long outputTokens) {  
  
        AILog log = repository.findByRequestId(requestId)  
                .orElseThrow(() -> new RestApiException(AILogErrorCode.UUID_NOT_FOUND, requestId));  
  
        LocalDateTime now = LocalDateTime.now();  
        log.success(now, inputTokens, outputTokens);  
  
        log.getOutputContent().putAll(outputContent == null ? Map.of() : outputContent);  
    }  
  
    @Transactional  
    public void failure(  
            String requestId,  
            Long inputTokens,  
            String errorMessage) {  
  
        AILog log = repository.findByRequestId(requestId)  
                .orElseThrow(() -> new RestApiException(AILogErrorCode.UUID_NOT_FOUND, requestId));  
  
        LocalDateTime now = LocalDateTime.now();  
        log.fail(now, errorMessage, inputTokens);  
    }  
  
}
```


# 루틴 체크

```tasks
not done
```

# 완료

```tasks
done
done today
```
