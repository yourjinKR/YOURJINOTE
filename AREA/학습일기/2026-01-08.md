# TODO




```tasks

```


# 개인 프로젝트

AI 서비스 요청 DTO(메타 데이터)  -> DTO의 메타 데이터를 기반으로 로그에 기록


### 현재 서비스 레이어에서 수행하는 작업

- prompt 생성
- API 호출 및 응답
- 로깅



## 로깅

spring ai 를 프로젝트에 도입 했음. 
현재는 API 요청 방식으로 간단히 구현했으며 해당 로직에 요청 로그에 대해서도 기록해야 돼.
아래 요구사항 및 의도를 읽고 앞으로  나의 질문에 답변해줬으면 좋겠어.

### 요구사항

- spring ai에 대해 처음 학습하며 적용하므로 친절한 설명이 필요함
- 공식문서 및 공신력 있는 자료를 기반으로 정리한 내용 전달 (참고한 사이트의 링크를 첨부해주면 베스트)
- 코드는 전반적으로 객체지향적이며 읽기 좋은 코드로 작성

### 현재 코드

```java
@Override  
public List<AIRoutineResponse> generateRoutine(AIRoutineRequest request) {  
  
    ChatClient chatClient = ChatClient.create(openAiChatModel);  
  
    SystemMessage systemMessage = new SystemMessage(SystemPromptConstant.ROUTINE_REQUEST);  
    UserMessage userMessage = new UserMessage(MessageFormat.format("내 정보 : {0}", request.toString()));  
    AssistantMessage assistantMessage = new AssistantMessage("");  
  
    OpenAiChatOptions options = OpenAiChatOptions.builder()  
            .model(MODEL)  
            .temperature(0.7)  
            .build();  
  
    Prompt prompt = new Prompt(List.of(systemMessage, userMessage, assistantMessage), options);  
  
      
  
    return chatClient.prompt(prompt)  
            .tools(new AITools(exerciseRepository, exerciseMapper))  
            .call()  
            .entity(new ParameterizedTypeReference<>() {});  
}
```

### build.gradle

현재 프로젝트 환경 이해를 위해

```groovy
plugins {  
    id 'java'  
    id 'org.springframework.boot' version '3.5.9'  
    id 'io.spring.dependency-management' version '1.1.7'  
}  
  
group = 'app'  
version = '0.0.1-SNAPSHOT'  
description = 'backend'  
  
java {  
    toolchain {  
        languageVersion = JavaLanguageVersion.of(21)  
    }  
}  
  
configurations {  
    compileOnly {  
        extendsFrom annotationProcessor  
    }  
}  
  
repositories {  
    mavenCentral()  
}  
  
ext {  
    set('queryDslVersion', "5.0.0")  
    set('springAiVersion', "1.1.2")  
}  
  
dependencies {  
    implementation 'org.springframework.boot:spring-boot-starter-data-jpa'  
    implementation 'org.springframework.boot:spring-boot-starter-thymeleaf'  
    implementation 'org.springframework.boot:spring-boot-starter-validation'  
    implementation 'org.springframework.boot:spring-boot-starter-web'  
    compileOnly 'org.projectlombok:lombok'  
    developmentOnly 'org.springframework.boot:spring-boot-devtools'  
    runtimeOnly 'com.mysql:mysql-connector-j'  
    annotationProcessor 'org.projectlombok:lombok'  
    testImplementation 'org.springframework.boot:spring-boot-starter-data-jpa-test'  
    testImplementation 'org.springframework.boot:spring-boot-starter-thymeleaf-test'  
    testImplementation 'org.springframework.boot:spring-boot-starter-validation-test'  
    testImplementation 'org.springframework.boot:spring-boot-starter-webmvc-test'  
    testRuntimeOnly 'org.junit.platform:junit-platform-launcher'  
  
    implementation "com.querydsl:querydsl-jpa:${queryDslVersion}:jakarta"  
    annotationProcessor "com.querydsl:querydsl-apt:${queryDslVersion}:jakarta"  
    annotationProcessor "jakarta.annotation:jakarta.annotation-api"  
    annotationProcessor "jakarta.persistence:jakarta.persistence-api"  
  
    implementation 'org.jspecify:jspecify:1.0.0'  
  
    // Spring AI  
    implementation 'org.springframework.ai:spring-ai-starter-model-openai'  
}  
  
dependencyManagement {  
    imports {  
        mavenBom "org.springframework.ai:spring-ai-bom:${springAiVersion}"  
    }  
}  
  
// 1. Q-Class를 생성할 디렉토리 경로를 설정합니다.  
def queryDslSrcDir = 'src/main/generated/querydsl/'  
  
// 2. JavaCompile Task를 수행하는 경우 생성될 소스코드의 출력 디렉토리를 queryDslSrcDir로 설정합니다.  
tasks.withType(JavaCompile).configureEach {  
    options.getGeneratedSourceOutputDirectory().set(file(queryDslSrcDir))  
}  
  
// 3. 소스 코드로 인식할 디렉토리에 경로에 Q-Class 파일을 추가합니다. 이렇게 하면 Q-Class가 일반 Java 클래스처럼 취급되어 컴파일과 실행 시 클래스패스에 포함됩니다.  
sourceSets {  
    main.java.srcDirs += [queryDslSrcDir]  
}  
  
// 4. clean Task를 수행하는 경우 지정한 디렉토리를 삭제하도록 설정합니다. : 자동 생성된 Q-Class를 제거합니다.  
clean {  
    delete file(queryDslSrcDir)  
}  
  
configurations {  
    compileOnly {  
        extendsFrom annotationProcessor  
    }  
    // 5. QueryDSL과 관련된 라이브러리들이 컴파일 시점에만 필요하도록 설정합니다. 또한, QueryDSL 설정을 컴파일 클래스패스에 추가합니다.  
    querydsl.extendsFrom compileClasspath  
}  
  
tasks.named('test') {  
    useJUnitPlatform()  
}

```