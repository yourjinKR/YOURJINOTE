# 참고자료
https://intotherealworld.tistory.com/9

# 코틀린이 뭘까?
[[10분 테코톡] 부나의 Java에서 Kotlin으로](https://www.youtube.com/watch?v=eA8e18ddSms)
## 탄생 과정
기존의 자바 : 자바는 유지보수에 골칫거리가 많음, 단순한 기능에도 너무 많은 자바 코드가 필요함

아래와 같은 목적을 지니면서 Kotlin이 생겨났다.
1. 속도
2. 상호 운용성
3. 간결성

## Kotilin 장점
### 1. 정적 타입 지정 언어
Kotlin은 정적 타입 지정 언어이며 컴파일러가 코드를 검증하고 컴파일하기 때문에 런타임 오류를 줄임

### 2. 타입 추론
변수 선언 시 타입을 작성하지 않아도 `val`, `var` 키워드만으로도 가능하다.
```kotlin
val name = "유어진"
var age = 26
val mind = "오픈 미션 화이팅 !!!"
```
- `val` : final
- `var` : 가변 

코틀린에서는 필드가 아닌 프로퍼티라고 말한다. 그 이유는 getter와 setter를 자동으로 만든다.

### 3.  Null Safety
Kotlin은 Null을 다루는 방식이 명확하게 정해져 있기 때문에 Null Saftey를 보장한다.
```kotlin
fun main() {
    var name: String? = null // ?를 붙이면 Nullable함
    println(name.length) // 여기서부터 경고 발생
}
```

```kotlin
fun main() {
    var name: String? = null 
    println(name?.length) // ?를 붙여 해결 가능
}
```
이와 같은 과정은 당연히 실행하기 전부터 컴파일러가 코드를 검증하여 알려줌 

**Evis 연산자 [ ?: ]**
```java
fun main() {
    var name: String? = null
    println(name ?: "yourjin")
}
```

### 4. 코드의 간결성과 명확성
Kotlin은 Java에 비해 코드를 간결하고 명확하게 작성할 수 있다.
그렇기 때문에 비교적 코드를 파악하기 쉽다는 장점이 있다.

**SAM(Single Abstract Method)**
단 하나의 추상화 함수를 가지고 있는 함수형 인터페이스를 뜻한다.

### 5. Coroutine
비동기적 코드를 쉽게 작성할 수 있도록 해당 기능을 제공
> 코틀린 고유의 개념은 아님!

## Java와 상호 운용
코틀린 코드를 컴파일시 자바 바이트 코드를 만들기 때문에 똑같이 동작

# 코틀린 생성자
[Kotlin 기초강의#4 :: 코틀린 클래스의 선언과 생성자](https://manorgass.tistory.com/79)
## 자바에서 생성자
```java
class Person {
	private String name;
	private int age;
	
	public Person(String name, int age) {
		this.name = name;
		this.age = age;
	}
}
```
자바에서는 다음과 같이 생성자를 작성한다.

코틀린은 아래와 같이 다양한 생성자 작성 방식이 있다.
```kotlin
// 일반적인 생성자 방식  
class Person {  
    constructor(name: String, age: Int) {  
        this.name = name  
        this.age = age  
    }  
    var name: String = ""  
    var age: Int = 0  
}  
  
// 클래스명 옆에 기본 생성자를 선언 가능함  
class Person2 constructor(name: String, age: Int) {  
    var name: String = name  
    var age: Int = age  
}  
  
// constructor 생략 가능  
class Person3(name: String, age: Int) {  
    var name: String = name  
    var age: Int = age  
}  
  
// 내부에서 프로퍼티 선언 가능  
class Person4(var name: String, var age: Int) {  
}  
  
// 이런식으로 생성자 지정 가능  
class Person5(name: String, age: Int) {  
    constructor(name: String) : this(name, age = 0) {  
        this.name = name  
    }  
    var name: String = name  
    var age: Int = age  
}  
  
// 기본값 설정  
class Person6(var name: String = "개발자", var age: Int = 0) {}  
  
fun main() {  
    val p51 = Person5("유어진")  
    val p52 = Person5("유어진", 26)  
  
    val p61 = Person6()  
    val p62 = Person6("유어진")  
    val p63 = Person6(age = 26)  
}
```
여기서 주목할 점은 **주 생성자를 지정**할 수 있을 뿐만 아니라 **기본값도 설정**할 수 있다는 것이다 

# 코틀린에서 정적 변수와 메서드
자바에서는 `static`이지만 코틀린에서는 `companion object` 내부에서 선언하여 구현

```kotlin
// static == companion object  
class Calculator {  
    companion object {  
        var code = 123  
        fun sumStringList(strList: List<String>): Int {  
            return strList.sumOf { it.toInt() }  
        }  
    }  
}  
  
fun main() {  
    println(Calculator.code)  
    val sum = Calculator.sumStringList(listOf("1", "2", "3"))  
    println(sum)  
}
```
## 싱글톤
심지어 싱글톤을 자체적으로 지원함
```kotlin
fun main() {  
    println(Singleton.NAME)  
    println(Singleton.MIND)  
}  
  
// object는 자체적으로 지원하는 싱글톤이 적용된 클래스  
object Singleton {  
    val NAME = "유어진"  
    val MIND = "재밌게 살자"  
}
```
