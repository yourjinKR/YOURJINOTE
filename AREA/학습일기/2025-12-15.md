
# 기초 학습

[Date와 Calendar 클래스](https://github.com/yourjinKR/YOURJINOTE/blob/7d9a5486bd38c236a5b95687149df5f0d2d7774f/RESOURCE/JAVA/Java-Time.md)
[java.time 패키지](https://github.com/yourjinKR/YOURJINOTE/blob/7d9a5486bd38c236a5b95687149df5f0d2d7774f/RESOURCE/JAVA/Java-Time.md)  
[timestamp](https://github.com/yourjinKR/YOURJINOTE/blob/7d9a5486bd38c236a5b95687149df5f0d2d7774f/RESOURCE/CS/Timestamp.md)

# 팀 프로젝트

[feat: 운동 루틴 리스트 조회 API 구현](https://github.com/yourjinKR/fitsync2-backend/pull/17)


## 2026 포트폴리오 전략

- 비용 측면을 고려한 프로젝트

[출처](https://www.youtube.com/watch?v=Axlxk_PaSOg&t=168s)
### AI를 활용한 팀 프로젝트 개발
- AI 서비스가 있는 팀 프로젝트를 개발하자, 회사들이 우리 서비스에 어떻게 AI 기술을 접목할 수 있을지 대해 고민하고 있음.

> 이거는 기존에 했던 fitsync 프로젝트에서 AI 서비스를 담당함. 이를 고도화하는 작업까지 수행하자.


### 코드 구현보다는 설계
- 프롬프트 엔지니어링에 대한 중요성과 비슷한 맥락 

### 원론적인 공부
- AI가 작성해준 코드가 좋은 코드인지 판단하는 근거는 CS 지식이다.

> 꾸준히 CS 공부하자...

### 비용 측면에서 분석한 프로젝트
- 회사에서 비용을 고려함, 이를 신입이 고려했다면 킥이 될 수 있음.

> AI api 요청에 대한 로그 기록이 곧 운영 비용의 일부임.
> 추가로 AI 서비스를 고도화 하고 모델별 사용 토큰량을 비교해보자.

### 아이디어 실현, 문제 해결 경험
- 아이디어를 실제 서비스로 개발하고 운영하자


# 프로젝트

### SpecBuilder 유틸화

제네릭을 활용하여 도메인에 맞는 SpecBuilder를 만들도록 수정

```java
public class SpecificationBuilder<T> {

    private final List<Specification<T>> specs = new ArrayList<>();

    public static <T> SpecificationBuilder<T> builder() {
        return new SpecificationBuilder<>();
    }

    public SpecificationBuilder<T> andEqual(String fieldName, Object value) {
        if (value != null) {
            specs.add(((root, query, builder) -> builder.equal(root.get(fieldName), value)));
        }
        return this;
    }

    public SpecificationBuilder<T> andLike(String fieldName, String value) {
        if (value != null && !value.trim().isEmpty()) {
            specs.add((root, query, builder) -> builder.like(root.get(fieldName), "%" + value + "%"));
        }
        return this;
    }

    public SpecificationBuilder<T> and(boolean condition, Specification<T> spec) {
        if (condition) {
            specs.add(spec);
        }
        return this;
    }

    public Specification<T> build() {
        if (specs.isEmpty()) {
            return null; // 또는 Specification.where(null);
        }

        Specification<T> result = specs.get(0);
        for (int i = 1; i < specs.size(); i++) {
            result = Specification.where(result).and(specs.get(i));
        }
        return result;
    }
}
```

### 연관관계 엔티티에 대한 검색

```java
public class SpecificationBuilder<T> {

    // 경로 탐색 헬퍼 메서드 추가
    private Path<?> getPath(Root<T> root, String attributeName) {
        if (attributeName.contains(".")) {
            String[] paths = attributeName.split("\\.");
            Path<?> path = root.get(paths[0]);
            for (int i = 1; i < paths.length; i++) {
                path = path.get(paths[i]);
            }
            return path;
        }
        return root.get(attributeName);
    }

    public SpecificationBuilder<T> andEqual(String fieldName, Object value) {
        if (value != null) {
            // root.get(fieldName) 대신 getPath() 사용
            specs.add((root, query, builder) -> 
                builder.equal(getPath(root, fieldName), value)
            );
        }
        return this;
    }

    public SpecificationBuilder<T> andLike(String fieldName, String value) {
        if (value != null && !value.trim().isEmpty()) {
            // String 캐스팅이 필요하므로 Path<String>으로 처리
            specs.add((root, query, builder) -> 
                builder.like(getPath(root, fieldName).as(String.class), "%" + value + "%")
            );
        }
        return this;
    }
    
    // ... 나머지 메서드(and, build)는 기존과 동일 ...
}
```


```java
public class RoutineSpec {  
    public static Specification<Routine> searchWith(  
            Long ownerId,  
            Long writerId  
    ) {  
        return SpecificationBuilder.<Routine>builder()  
                .andEqual("owner.id", ownerId)  
                .andEqual("writer.id", writerId)  
                .build();  
    }  
}
```

점으로 체이닝하여 접근


> 추후 QueryDSL 적용 시도


### QueryDSL

클래스명이 "인터페이스명 + Impl" 인지 주의하자

> jpa가 해당 이름 형식으로 찾기 때문

```java
public interface ExerciseRepositoryQueryDSL {
    Page<Exercise> search(Pageable pageable, ExerciseCategory category, boolean hidden);
}

@RequiredArgsConstructor
public class ExerciseRepositoryQueryDSLImpl implements ExerciseRepositoryQueryDSL {

    private final JPAQueryFactory queryFactory;
}
```