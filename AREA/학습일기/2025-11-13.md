- [x] 면접 질문 정리
	- [x] 컴파일 언어와 인터프리터 언어
- [x] 코틀린 프로젝트
	- [x] quizConfig와 quiz에 level과 type을 변경 요청
	- [x] userRepository 요청
	- [x] `buildQuizAnswer`에 `mapIndexed`로 사용하여 `questionNumber`를 리스트의 인덱스로
	- [x] 현재 브리핑
		- [x] 퀴즈 기록 등록은 유저 연관관계만 매핑
		- [x] 퀴즈 기록 리스트는 완성, 그러나 `JpaSpecificationExecutor` 사용 여부 물어보기
		- [x] 퀴즈 기록 상세보기는 dto 수정되고 같이 쓸 수 있다면 통합
		- [x] 퀴즈 기록 통계는 어떤걸 할까?
			- [x] 연속 퀴즈 풀이 일수
			- [x] 정답률(?)
			- [x] 평균 풀이 시간
			- [x] 주로 플레이하는 시간대

# 회의 내용
- [x] 전역 jpa수정에 대한거  
- [x] 정상응답에 대한 response

# 컴파일 언어와 인터프리터 언어
컴파일 = 번역, 미리 번역 (C, Java)
인터프리트 = 통역, 실시간 통역 (Javascript, Python)


# JPA 쿼리 줄이기
``` kotlin
/**
 * 퀴즈 기록 상세 조회
 */
override fun getUserQuizRecordDetail(recordId: Long): QuizRecordDetailResponse {
	val quizRecord = quizRecordRepository.findById(recordId)
		.orElseThrow { EntityNotFoundException("퀴즈 기록을 찾을 수 없습니다. ID: $recordId") }

	return QuizRecordDetailResponse.from(quizRecord)
}
```

```kotlin
interface QuizRecordRepository : JpaRepository<QuizRecord, Long> {

    @Query(
        """
        select distinct qr
        from QuizRecord qr
            join fetch qr.user u
            join fetch qr.config cfg
            left join fetch qr.answers ans
            left join fetch ans.quiz q
            left join fetch ans.option opt
        where qr.id = :recordId
        """
    )
    fun findDetailById(@Param("recordId") recordId: Long): QuizRecord?
}
```
user 부분 완성되면 시도해보자


# 코틀린 : LocalDateTime
## 연속일 구하기
```kotlin
// 날짜 비교  
fun getDayGap(today: LocalDateTime, tomorrow: LocalDateTime): Long {  
    return abs(ChronoUnit.DAYS.between(today, tomorrow))  
}  
  
println(getDayGap(list[0], list[2])) // 2  
  
// 연속일 구하기  
fun getStreakDay(dateList: List<LocalDateTime>): Int {  
    var peakDay = INIT_STREAK_DAY;  
    for (i in 0..<dateList.size - 1) {  
        val isTomorrow = getDayGap(dateList[i], dateList[i + 1])  
  
        when {  
            isTomorrow == 0L -> peakDay  
            isTomorrow == 1L -> peakDay++  
            isTomorrow > 1L -> peakDay = INIT_STREAK_DAY  
        }  
    }  
    return peakDay  
}  
  
println(getStreakDay(list))
```
## 시간 구하기
```kotlin
// 시간 구하기  
fun getSolveTime(d1: LocalDateTime, d2: LocalDateTime): Long {  
    val duration = Duration.between(d1, d2)  
    return duration.seconds  
}
```

# Enum과 EnumMap
## `List<Enum>`을 `EnumMap<Enum, 갯수>`로 변환

```kotlin
val quizRecordList: List<QuizRecord> = quizRecordRepository.findAll() 
```
### 방법1 : 기본
```kotlin
val timeRanges = quizRecordList.map { it.getSolvedTimeRange() }
val counted = timeRanges.groupingBy { it }.eachCount()

val fullMap = EnumMap<TimeRange, Int>(TimeRange::class.java).apply {
    TimeRange.entries.forEach { range ->
        this[range] = counted[range] ?: 0
    }
}
```
### 방법2 : associateWith 활용
```kotlin
val timeRanges = quizRecordList.map { it.getSolvedTimeRange() }
val counted = timeRanges.groupingBy { it }.eachCount()

val fullMap = EnumMap<TimeRange, Int>(TimeRange::class.java).apply {
    putAll(TimeRange.entries.associateWith { counted[it] ?: 0 })
}
```
### 방법3 : 한줄로 처리
```kotlin
val activePlayTimeRange = EnumMap(  
    TimeRange.entries.associateWith { range ->  
        quizRecordList  
            .map { it.getSolvedTimeRange() }  
            .groupingBy { it }  
            .eachCount()[range] ?: 0  
    }  
)
```

## `associateWith()`



```sql
CREATE TABLE `quiz_configs` (
  `config_id` bigint NOT NULL AUTO_INCREMENT,
  `created_at` datetime(6) NOT NULL,
  `updated_at` datetime(6) DEFAULT NULL,
  `level` enum('ADVANCED','BEGINNER','INTERMEDIATE') NOT NULL,
  `quiz_name` varchar(50) NOT NULL,
  PRIMARY KEY (`config_id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci
```