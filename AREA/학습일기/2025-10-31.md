# List 중복 검증
​[mangdo[Java] 리스트 내 요소 중복 체크](https://doing7.tistory.com/145)​
```java
private void validateDuplicate(List<Integer> numbers) {
    long numberSize = numbers.size();
    long numberUniqueSize = numbers.stream().distinct().count();

    if (numberSize != numberUniqueSize) {
        throw new IllegalArgumentException("에러");
    }
}
```

# List의 범위값 검증하기
## `anyMatch()` 활용

```java
private void validateRange(List<Integer> numbers) {  
    int LOWER_BOUND = 1;  
    int UPPER_BOUND = 45;  
  
    boolean outOfRange = numbers.stream()  
            .anyMatch(number -> (number < LOWER_BOUND) || (number > UPPER_BOUND));  
  
    if (outOfRange)  
        throw new IllegalArgumentException("에러");  
}
```

stream API의 `anyMatch`를 활용하여 구현함
이게 최선일까?

## `contains()` 활용

[[JAVA] 특정 범위 정수 리스트 생성하기, toList() vs Collectors.toList()](https://velog.io/@coastby/java-%ED%8A%B9%EC%A0%95-%EB%B2%94%EC%9C%84-%EC%A0%95%EC%88%98-%EB%A6%AC%EC%8A%A4%ED%8A%B8-%EC%83%9D%EC%84%B1%ED%95%98%EA%B8%B0-toList-vs-Collectors.toList)​
```java
private void validateRange(List<Integer> numbers) {  
    int LOWER_BOUND = 1;  
    int UPPER_BOUND = 45;  
  
    List<Integer> boundList = IntStream.range(LOWER_BOUND, UPPER_BOUND).boxed().toList();  
  
    boolean safeRange = numbers.stream()  
            .allMatch(number -> boundList.contains(number));  
  
    if (!safeRange)  
        throw new IllegalArgumentException("에러");  
}
```

## `containsAll()` 활용

아래와 같이 축약 가능
```java
// boundList가 numbers에 있는 모든 요소를 포함하고 있는가?
boolean safeRange = boundList.containsAll(numbers);
```

그런데 Intellij에서 아래와 같은 코드를 추천해줌
```java
boolean safeRange = new HashSet<>(boundList).containsAll(numbers);
```

![[Pasted image 20251031024348.png|300]]

[출처 : jetbarins : Call to 'list.containsAll(Collection)' may haver poor perfomance](https://www.jetbrains.com/help/inspectopedia/SlowListContainsAll.html#locating-this-inspection)

시간복잡도 감소를 할 수 있기에 추천함.

`containsAll()`이란건 애초에 이 값이 포함되어 있는가를 검사하는 것이기에
배열 내 중복되는 데이터를 제거할 필요가 있음.

그럼에도 불구하고 앞서 언급한 방법보다 좋지는 않을거 같음.

`anyMatch`로직은 최대값보다 크거나 최소값보다 작은지만 판단

