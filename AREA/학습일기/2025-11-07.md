- [x] mysql 설치
- [x] 면접 점검
- [x] 1일 1리뷰
- [ ] 코틀린 1차 과제 풀이 및 정리
- [ ] API 명세서 재점검

# MySql 재설치
[재설치 참고 링크](https://life-of-dev.tistory.com/entry/MySQL-%EC%99%84%EC%A0%84-%EC%82%AD%EC%A0%9C-%ED%9B%84-%EC%9E%AC%EC%84%A4%EC%B9%98)

# 코틀린에서 클래스와 인터페이스
https://hudi.blog/kotlin-basic-04-class/
[lateint와 lazy 사용](https://velog.io/@haero_kim/Kotlin-lateinit-vs-lazy-%EC%A0%95%ED%99%95%ED%9E%88-%EC%95%84%EC%84%B8%EC%9A%94)
## interface의 프로퍼티 사용하기
https://cornswrold.tistory.com/469#google_vignette
```kotlin
/*
    버스는 이동수단 인터페이스를 구현함
    아래와 같이 인터페이스의 프로퍼티는 주 생성자를 통해 오버라이드 가능
 */
class Bus(override val name: String) : Vehicle {
    override fun goForward() {
        println("$name 가 앞으로 감")
    }

    override fun goBack() {
        println("$name 가 뒤로 감")
    }
}
```

# 코틀린 when
```kotlin
fun describe(obj: Any): String =
    when (obj) {
        1          -> "One"
        "Hello"    -> "Greeting"
        is Long    -> "Long"
        !is String -> "Not a string"
        else       -> "Unknown"
    }
```
자바의 switch문과 같이 사용할 수 있다.
[공식 문서](https://kotlinlang.org/docs/basic-syntax.html#when-expression)

```kotlin
fun safetyTake(rawData: String) {  
    when {  
        (rawData.length < 5) -> throw IllegalArgumentException("error")  
    }  
    rawData.take(5)  
}
```
과제에서는 아래와 같이 사용했었음

> 사실 위 코드는 필요가 없음, take는 substring과 다르게 out of range를 발생시키지 않았다

# 코틀린 take
`substring`을 사용하던 도중 인텔리제이에서 take 사용을 추천함 
```kotlin
val string = "12"  
println(string.substring(0,5)) // 에러
println(string.take(5))
```

## take와 substring의 차이점
`substring`은 `StringIndexOutOfBoundsException`를 발생
### take
- 코틀린 표준 함수
- 문자열의 앞에서부터 n개의 문자만 안전하게 잘라서 반환
- 길이를 초과해도 에러가 나지 않음

[공식 문서](https://kotlinlang.org/api/core/kotlin-stdlib/kotlin.text/take.html)

# 코틀린 collection
[공식문서](https://kotlinlang.org/docs/collections-overview.html)
[kotlin 에서 stream 을 지워보자, kotlin 함수를 사용하기](https://blog.yevgnenll.me/posts/remove-stream-in-kotlin)
[[Kotlin] Collection 날먹하는 함수들](https://velog.io/@haero_kim/Kotlin-Collection-%EB%82%A0%EB%A8%B9%ED%95%98%EB%8A%94-%ED%95%A8%EC%88%98%EB%93%A4)

# 코틀린 val과 const의 차이
const val 는 컴파일 시간에 결정되는 상수이다.
런타임에 할당되는 val 와 달리 컴파일 시간 동안 할당이 되어야 한다.
즉, const 는 함수나 어떤 클래스의 생성자에게도 결코 할당 될 수 없고
오직 문자열이나 기본 자료형으로 할당되어야 한다.

[https://kimch3617.tistory.com/entry/Kotlin에서-val-와-const-val-의-차이](https://kimch3617.tistory.com/entry/Kotlin%EC%97%90%EC%84%9C-val-%EC%99%80-const-val-%EC%9D%98-%EC%B0%A8%EC%9D%B4) [코드 저장소:티스토리]

# 객체 생성시 내부에서 검증
[객체 내부에서 검증](https://yeong0jae.tistory.com/19)
```kotlin
package racingcar.domain  
  
class Car(val name: String) {  
    companion object {  
        private const val NAME_MAX_LENGTH = 5  
    }  
  
    var distance = 0  
  
    private fun validateName(name: String) {  
        if (name.length > NAME_MAX_LENGTH) {  
            throw IllegalArgumentException("")  
        }  
    }  
  
    fun goForwardByPicker(numPicker: NumPicker) {  
        val num = numPicker.pick()  
        if (num >= 4) distance++  
    }  
}
```
name을 지정할때 검증과정을 거쳐야 함.
어떻게 하는게 좋을까?
## init 사용
```kotlin
package racingcar.domain  
  
class Car(val name: String) {  
    companion object {  
        private const val NAME_MAX_LENGTH = 5  
    }  
  
    var distance = 0  
        private set  
    init {  
        validateName(name)  
    }  
  
    private fun validateName(name: String) {  
        if (name.length > NAME_MAX_LENGTH) {  
            throw IllegalArgumentException("")  
        }  
    }  
  
    fun goForwardByPicker(numPicker: NumPicker) {  
        val num = numPicker.pick()  
        if (num >= 4) distance++  
    }  
}
```
`init`을 사용하면 객체 생성 후 실행할 로직을 추가할 수 있다다

## 정팩메 사용
```kotlin
package racingcar.domain

class Car private constructor(val name: String) {

    companion object {
        private const val NAME_MAX_LENGTH = 5

        fun of(name: String): Car {
            validateName(name)
            return Car(name)
        }

        private fun validateName(name: String) {
            if (name.isBlank()) {
                throw IllegalArgumentException("에러")
            }
            if (name.length > NAME_MAX_LENGTH) {
                throw IllegalArgumentException("에러")
            }
        }
    }

    var distance = 0
        private set

    fun goForwardByPicker(numPicker: NumPicker) {
        val num = numPicker.pick()
        if (num >= 4) distance++
    }
}

```
아니면 별도의 정팩메를 만들어 정팩메 내부에서 `validate`하는 방식 또한 가능

## 검증 시점 미루기
값을 대입하기 전에 검증을 먼저 수행하고자 한다면 이와 같이 실행
```kotlin
class Car(name: String) {  
    companion object {  
        const val NAME_MAX_LENGTH = 5  
  
        fun copyOf(car: Car): Car {  
            return Car(car.name)  
        }  
    }  
  
    init { validateName(name) } // 검증시점 여기서 수행!
  
    val name: String = name
    var distance: Int = 0  
  
    private fun validateName(name: String) {  
        require(name.isNotBlank()) { ErrorMessage.CAR_NAME_EMPTY.message }  
        require(name.length <= NAME_MAX_LENGTH) { ErrorMessage.CAR_NAME_LENGTH.message }  
    }  
  
    fun goForwardByPicker(numPicker: NumPicker) {  
        val num = numPicker.pick()  
        if (num >= 4) distance++  
    }  
}
```
**init 블록은 property 초기화와 함께 class의 body 내에서 "순서대로"** **실행**

```kotlin
val name: String  
var distance: Int = 0  
  
init {  
    validateName(name)  
    this.name = name  
}
```
이와 같은 순서도 가능할 것임

# 코틀린 객체 복사 방식
https://sh1mj1-log.tistory.com/229
```kotlin
class Car(val name: String, var distance: Int = 0) {  
    companion object {  
        const val NAME_MAX_LENGTH = 5  
  
        fun copyOf(car: Car): Car {  
            return Car(car.name, car.distance)  
        }  
    }
}
```
정팩메 활용

# 코틀린 getter setter에 대한 이해
```kotlin
class Racing private constructor(val cars: List<Car>, val totalTurn: Int) {  
    companion object {  
        const val TURN_MINIMUM = 1  
  
        fun carsTotalTurnOf(cars: List<Car>, totalTurn: Int): Racing {  
            return Racing(cars, totalTurn)  
        }  
    }  
	
	// 여기서 선언 후 커스텀 해야 됨
    var nowTurn: Int = 1  
        private set
}
```
- `val`은 setter 없음, getter 자동 생성
- `var`은 setter, getter 자동 생성
## getter/setter
```kotlin
// 여기서 선언 후 커스텀 해야 됨
var nowTurn: Int = 1  
	private set
```
- 내부에서 아래와 같이 커스텀한다
# 코틀린 enum으로 에러 메세지 관리
[[Kotlin] enum class에 대하여](https://velog.io/@gjgustjd70/Kotlin-enum-class%EC%97%90-%EB%8C%80%ED%95%98%EC%97%AC-s5r0tt2s)
```kotlin
enum class ErrorMessage(val message: String) {  
    INPUT_NAME_LIST("자동차의 이름은 쉼표(,)로 구분하여 입력하시오"),  
    INPUT_TRY_TURN("시도 횟수는 최소 ${Racing.TURN_MINIMUM}이상 입력하시오"),  
  
    CAR_NAME_EMPTY("자동차의 이름은 비어 있을 수 없습니다"),  
    CAR_NAME_LENGTH("자동차의 이름은 최대 ${Car.NAME_MAX_LENGTH}글자 입니다"),  
  
    RACING_CARS_EMPTY("경주에는 최소 하나의 자동차가 있어야 합니다."),  
    RACING_TURN_INVALID("레이싱 시도 횟수 기회는 최소 ${Racing.TURN_MINIMUM}번입니다")  
}
```

## enum의 setter와 getter
message에 고정된 문자를 붙여야 하기에 enum에서 getter와 setter 커스텀 방식에 대해 알아봄

> enum은 열거형 자료형이기에 setter는 없음, 
```kotlin
enum class ErrorMessage(private val rawMessage: String) {  
    INPUT_NAME_LIST("자동차의 이름은 쉼표(,)로 구분하여 입력하시오"),  
    INPUT_TRY_TURN("시도 횟수는 최소 ${Racing.TURN_MINIMUM}이상 입력하시오"),  
  
    CAR_NAME_EMPTY("자동차의 이름은 비어 있을 수 없습니다"),  
    CAR_NAME_LENGTH("자동차의 이름은 최대 ${Car.NAME_MAX_LENGTH}글자 입니다"),  
  
    RACING_CARS_EMPTY("경주에는 최소 하나의 자동차가 있어야 합니다."),  
    RACING_TURN_INVALID("레이싱 시도 횟수 기회는 최소 ${Racing.TURN_MINIMUM}번입니다");  
  
    private val PREFIX = "[ERROR]"  
  
    val message: String  
        get() = "$PREFIX $message"  
}
```
val를 추가하여 위와 같이 구현, message로 똑같이 호출하되 getter를 커스텀하여 구현

# 면접 점검
https://www.woowacourse.io/apply
## 우테코 얘기를 할까?
혹시 제가 저번달부터 우아한 형제들에서 진행하는 
교육코스 선발 과정 수행하고 있는데 이런것도 언급해도 될까요??

이를 내세워서 먼저 언급하다기 보다는 "최근에는 추가로 하고 있는 활동 있나요?" 같이 관련 질문 있을때만 할거 같아요

절대로 유명한 교육코스라서 지원했다기 보다는 저의 생각을 전달드리고 싶어서 아래와 같이 정리해봤는데 한번 피드백 주시면 감사하겠습니다 ㅠㅠ

제가 해당 교육코스를 지원했던 이유는...

1. 기초 다잡기
	1. 프레임워크와 같은 특정 기술에 의존이 아닌 개발언어 지식에 대한 수준 파악하고자 했음
2. 코드 리뷰
	1. 과정 중 참가자들 간 코드 리뷰 활동이 있음
	2. 남의 코드를 직접 보고 피드백하는 경험이 없었음 (보통 구현한 기능을 기반으로 피드백)
	3. 다른 사람들의 코드와 그 의도를 보고 나의 생각을 공유하는 시간을 가져보고 싶었음
3. 인사이트 얻기
	1. 나와 같은 처지에 있는 다른 사람들의 생각이 궁금
	2. 우테코 프리코스에서 커뮤니티 활동이 활발히 이루어짐
	3. 기술적인 인사이트 뿐만 아니라 취준 과정 중 마음가짐에 대해서도 다시 한번 다잡게 됨
	4. 열심히 하는 사람들을 보며 자극 받기

3주차까지 후기 : 실제로 JAVA 언어에 대한 기본기가 늘어난 것을 체감 중

현황 : 현재는 오픈미션(자유 미션) 중이며 현재 코틀린 미니 프로젝트 진행중
1. 오픈미션은 성장, 도전과 관련된 자유 주제로 2주동안 진행함

코틀린 미니 프로젝트 목적 (현재 설계 단계, 간단한 영단어 서비스 개발)
1. 다양한 언어에 대한 경험하고 싶었음
2. 특히 코틀린에 대해 관심이 있었음 :자바와 완벽히 동기화되는 언어가 있는 등 다양한 강점을 가진 언어
3. 처음 배우는 기술을 빠르게 학습하고 프로젝트를 진행하는 경험을 통해 성장