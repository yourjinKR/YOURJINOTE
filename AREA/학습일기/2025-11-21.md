# ResponseBody vs ResponseEntity
[# [10분 테코톡] 제제의 ResponseBody vs ResponseEntity](https://www.youtube.com/watch?v=fCgU_VFv33M)

웹 서비스는 데이터를 주고 받을때 정해진 형식에 데이터를 응답하고 요청한다.
이를 http라고 함.
스프링에서는 이러한 정해진 응답 형식을 쉽게 구현할 수 있도록 아래 두개의 클래스를 지원한다.
## ResponseBody
http response에서 body에 들어온 값들을 직렬화 해주는 어노테이션
> **직렬화란?**
> 현재의 데이터를 네트워크에서 송/수신 가능하도록 변경하는 것
## ResponseEntity
`ResponseEntity`는 Spring MVC에서 HTTP 요청에 대한 응답을 제어하는 데 사용하는 클래스
## 둘은 어떻게 다르게 동작하는가?
### DispatcherServlet의 Handler Adapter와 Handler
Handler = 컨트롤러
Handler Adapter는 해당 요청에 도움을 주는 클래스?
#### RequestMappingHandlerAdapter
![Pasted image 20251121202346](Pasted%20image%2020251121202346.png)
ArgumentsResolver는 뭐지?

일단 둘은 ReturnValueHandler를 서로 다른 구현체를 사용함
![Pasted image 20251121202653](Pasted%20image%2020251121202653.png)

![Pasted image 20251121202708](Pasted%20image%2020251121202708.png)
동일한 구현체 차이가 있을뿐 동일한 매커니즘에 의해 HTTP 응답 생성함

## 어떤 걸 사용하면 좋을까?
### @ResponseBody
1. 코드가 깔끔함
2. 상태 코드와 헤더를 유연하게 변경하지 못함
#### 단점 극복 가능
- `@ResponseStatus`
- `HttpservletResponse`
### ResponseEntity
1. 상태 코드와 헤더를 유연하게 변경 가능
2. 작성할 코드 증가
## ResponseEntity는 왜 생겼는교
### 편의성
이것도 맞지만...
### 동적으로 응답 코드를 변경 가능
ResponseStatus는 정적임, 그런데 응답 코드를 동적으로 사용하기 위해 등장함
## 결론
뭘 쓰든지 간에 똑같은 녀석이며 해당 팀에서 어떤 가치를 추구하는가에 따라 다르다.

---


왜 ResponseEntity가 아닌 별개의 커스텀 DTO를 사용해야할까?

ResponseEnttiy의 역할은 무엇이며 구조는 어떤가?

Empty의 역할은 무엇이며 언제 header와 body가 비어있는 응답을 하는 것인가?


```java
public static <T> ResponseEntity<T> ok(@Nullable T body) {  
    return ok().<T>body(body);  
}
```

```java
public static BodyBuilder ok() {  
    return status(HttpStatus.OK);  
}
```

```java
public static BodyBuilder status(HttpStatusCode status) {  
    Assert.notNull(status, "HttpStatusCode must not be null");  
    return new DefaultBuilder(status);  
}
```

```java
private static class DefaultBuilder implements BodyBuilder {  
    private final HttpStatusCode statusCode;  
    private final HttpHeaders headers;  
    
    public DefaultBuilder(HttpStatusCode statusCode) {  
        this.headers = new HttpHeaders();  
        this.statusCode = statusCode;  
    }
}
```


### HttpEntity.EMPTY를 직접 사용하는 곳
```java
/**  
 * Request callback implementation that writes the given object to the request stream. */private class HttpEntityRequestCallback extends AcceptHeaderRequestCallback {  
  
    private final HttpEntity<?> requestEntity;  
  
    public HttpEntityRequestCallback(@Nullable Object requestBody) {  
       this(requestBody, null);  
    }  
  
    public HttpEntityRequestCallback(@Nullable Object requestBody, @Nullable Type responseType) {  
       super(responseType);  
       if (requestBody instanceof HttpEntity<?> httpEntity) {  
          this.requestEntity = httpEntity;  
       }  
       else if (requestBody != null) {  
          this.requestEntity = new HttpEntity<>(requestBody);  
       }  
       else {  
          this.requestEntity = HttpEntity.EMPTY;  
       }  
    }
}
```


```java

```

```java

```

```java

```

```java

```



---

# 개요
팀 프로젝트를 진행하던 중 개발환경을 만들어주신 팀원께서 아래와 같이 에러 응답 DTO를 별개로 만들어 관리하셨다.

```kotlin
/**
 * 에러 응답을 위한 DTO
 */
class ErrorResponse private constructor(
    code: String,
    message: String,
    val errors: List<ErrorDetailResponse> = emptyList(),
    val timestamp : Instant
)
```

이에 대해 다른 팀원께서 정상 응답에 대해서도 별개의 응답 DTO를 만들자는 의견이 있으셨다.

> 기존에 스프링에서 지원하는 `ResponseEntity`를 사용하면 되는데 왜 별개의 DTO를 굳이 만들어야 할까?

위와 같은 의문점을 시작으로 해당 글을 작성하게 됐습니다.

# ResponseEntity

```java
public class ResponseEntity<T> extends HttpEntity<T> {
    private final HttpStatusCode status;
}
```
`ResponseEntity`는 Spring MVC에서 HTTP 요청에 대한 응답을 제어하는 데 사용하는 클래스이다. 이 클래스는 `Response Body`, `Header`, `Status Code`를 포함할 수 있어, 세밀한 응답 관리를 가능하게 한다. `ResponseEntity`는 `@RestController`와 함께 사용되어 JSON 또는 XML과 같은 RESTful 서비스를 제공하는데 이상적이다.

>  **RESTful**
> 

`ResponseEntity`는 `HttpEntity`를 상속받고 있다.

# HttpEntity
```java
public class HttpEntity<T> {
    public static final HttpEntity<?> EMPTY;
    private final HttpHeaders headers;
    @Nullable
    private final T body;
}
```

`HttpEntity`는 http 요청에 필요한 `header`와 `body`를 가지고 있다.
그러나 정적 변수인 `EMPTY`는 무엇일까?

## EMPTY
```java
public class HttpEntity<T> {
    public static final HttpEntity<?> EMPTY;
    private final HttpHeaders headers;
    @Nullable
    private final T body;
    // 중략...
    static {
        EMPTY = new HttpEntity(HttpHeaders.EMPTY);
    }
}
```
우리의 `HttpEntity`는 이렇게 생겨먹었다.

```java
public HttpEntity(MultiValueMap<String, String> headers) {  
    this((Object)null, headers);  // body는 nullable하지만 (Object)로 형변환
}  
```

```java  
public HttpEntity(@Nullable T body, @Nullable MultiValueMap<String, String> headers) {  
    this.body = body;  
    this.headers = HttpHeaders.readOnlyHttpHeaders((MultiValueMap)(headers != null ? headers : new HttpHeaders()));  
}
```
위와 같은 흐름으로 body가 비어있는 `HttpEntity`를 만든다.

```java
public static HttpHeaders readOnlyHttpHeaders(MultiValueMap<String, String> headers) {  
    return (headers instanceof HttpHeaders httpHeaders ? readOnlyHttpHeaders(httpHeaders) :  
          new ReadOnlyHttpHeaders(headers));  
}
```
`HttpEntity`의 `headers`에는 다음과 같은 정적 메서드를 호출하여 헤더 정보를 저장한다.

```java
public static HttpHeaders readOnlyHttpHeaders(HttpHeaders headers) {  
    Assert.notNull(headers, "HttpHeaders must not be null");  
    return (headers instanceof ReadOnlyHttpHeaders ? headers : new ReadOnlyHttpHeaders(headers.headers));  
}
```
인자로 받은 `headers`가 `HttpHeaders`와 같은 타입이라면 위 로직을 통해 header 정보가 만들어지며

```java
public HttpHeaders(MultiValueMap<String, String> headers) {  
    Assert.notNull(headers, "MultiValueMap must not be null");  
    if (headers == EMPTY) {  // EMPTY
       this.headers = CollectionUtils.toMultiValueMap(new LinkedCaseInsensitiveMap<>(8, Locale.ENGLISH));  
    }  
    else if (headers instanceof HttpHeaders httpHeaders) {  
       while (httpHeaders.headers instanceof HttpHeaders wrapped) {  
          httpHeaders = wrapped;  
       }  
       this.headers = httpHeaders.headers;  
    }  
    else {  
       this.headers = headers;  
    }  
}
```
아닐 경우에는 다음과 같이 실행된다.

```java
public class HttpHeaders implements MultiValueMap<String, String>, Serializable {
	final MultiValueMap<String, String> headers;
}
```
`HttpHeaders`에 다음과 같은 타입으로 헤더 정보가 추가된다.

```java
class ReadOnlyHttpHeaders extends HttpHeaders {  
    private static final long serialVersionUID = -8578554704772377436L;  
    @Nullable  
    private MediaType cachedContentType;  
    @Nullable  
    @SuppressWarnings("serial")  
    private List<MediaType> cachedAccept;
}
```


말그대로 비어있음, `body`와 `header`에 어떠한 정보를 보낼 필요가 없을때 사용한다.

```java
public HttpEntity<?> 했어_무응답으로() {
    return HttpEntity.EMPTY;
}
```
그럼 이런 하도영(?) 같은 답변은 언제 필요할까?

## 무응답
```java

```


```java
public HttpEntity(MultiValueMap<String, String> headers) {  
    this((Object)null, headers);  
}  
  
public HttpEntity(@Nullable T body, @Nullable MultiValueMap<String, String> headers) {  
    this.body = body;  
    this.headers = HttpHeaders.readOnlyHttpHeaders((MultiValueMap)(headers != null ? headers : new HttpHeaders()));  
}
```


### 1. 204 No Content

### 2. 304 Not Modified

### 3. HEAD 요청 응답






### HttpEntity.EMPTY
`HttpEntity.EMPTY`를 직접 사용하는 곳은 어디일까? 라는 의문점을 시작으로 소스 코드를 찾아보기 시작했다.
```java
private class HttpEntityRequestCallback extends AcceptHeaderRequestCallback {  
    private final HttpEntity<?> requestEntity;  
  
    public HttpEntityRequestCallback(@Nullable Object requestBody) {  
        this(requestBody, (Type)null);  
    }  
  
    public HttpEntityRequestCallback(@Nullable Object requestBody, @Nullable Type responseType) {  
        super(responseType);  
        if (requestBody instanceof HttpEntity<?> httpEntity) {  
            this.requestEntity = httpEntity;  
        } else if (requestBody != null) {  
            this.requestEntity = new HttpEntity(requestBody);  
        } else {  
            this.requestEntity = HttpEntity.EMPTY;  
        }  
  
    }
}
```
`RestTemplate`에서 사용되는 것을 확인 할 수 있었다.

### RestTemplate이란?
- HTTP 통신을 위한 도구로 RESTful API 웹 서비스와의 상호작용을 쉽게 외부 도메인에서 데이터를 가져오거나 전송할 때 사용되는 스프링 프레임워크의 클래스를 의미합니다.
- 다양한 HTTP 메서드(GET, POST, PUT, DELETE 등)를 사용하며 원격 서버와 ‘동기식 방식’으로 JSON, XML 등의 다양한 데이터 형식으로 통신합니다.  
- 동기식 방식으로 요청을 보내고 응답을 받을 때까지 블로킹되며, 요청과 응답이 완료되기 전까지 다음 코드로 진행되지 않습니다. 원격 서버와 통신할 때는 응답을 기다리는 동안 대기해야 합니다.




# 출처
[RestTemplate이란](https://adjh54.tistory.com/234)