# 기초 학습

## JVM이란?

자바 애플리케이션을 실행하는 **가상머신**이다.

## JVM의 주요 특징

- 운영체제와 상관 없이 하나의 코드로 실행 가능하다

## JIT 컴파일러

기존 자바는 인터프리터 방식으로 명령어를 하나씩 실행하게끔 이루어져 있어 실행속도가 느렸다.  
그러나 JIT 컴파일러는 같은 코드를 매번 해석하지 않고 실행할 때 컴파일을 하면서 해당 코드를 캐싱한다. 이후에는 바뀐 부분만 컴파일하고 나머지는 캐싱된 코드를 사용한다.

> 해당 방식은 동적 번역이라고도 함

## 자바 프로그램 실행 과정

1. 자바 소스 코드를 작성한다.
2. JDK 컴파일러가 자바 소스 파일을 바이트 코드로 변환한다.
3. JVM의 클래스로더가 바이트 코드를 메모리에 로드한다.
4. JVM의 실해 엔진이 바이트코드를 운영체제에 맞는 기계어로 변환하고 실행한다.
5. 가비지 컬렉터가 메모리 관리를 자동으로 수행한다.

## JVM 구성요소

- Class Loader
- Runtime Data Areas
- Execution Engine
- JNI (Java Native Interface)
- Natvie Method Library

## 클래스 로더란?

자바 바이트 코드를 JVM 내부로 로드하는 역할을 수행  
클래스를 메모리에 적재  
필요한 클래스를 동적으로 로드

## 클래스 로더의 동작 흐름

### 전체적인 흐름

- **로딩** : 클래스 파일을 찾아서 메모리에 로드
- **연결** : 클래스 파일 간의 의존성을 해소, 심볼릭 래퍼런스를 메모리 주소로 변경
- **초기화** : 정적 필드 및 초기화 블록을 실행

### 세부 흐름

- 메서드 영역에 클래스가 로드되어 있는지 확인한다. 로드됐을 경우는 해당 클래스를 사용한다.
- 메서드 영역에 클래스가 로드되어 있지 않을 경우 시스템 클래스 로더에 클래스 로드를 요청한다.
- 시스템 클래스 로더는 확장 클래스 로더에 요청을 위임한다.
- 확장 클래스 로더는 부트스트랩 클래스 로더에 요청을 위임한다.
- 부트 스트랩 클래스 로더는 해당 클래스가 있는지 확인 후 존재하지 않는 경우 확장 클래스 로더에게 요청을 넘긴다.
- 확장 클래스 로더는 확장에 해당 클래스가 있는지 확인 후 클래스가 존재하지 않을 경우는 시스템 클래스 로더에게 요청을 넘긴다.
- 시스템 클래스 로더는 시스템 ClassPath에 해당 클래스가 있는지 확인한다.

> 최종적으로 클래스가 존재하지 않을 경우에는 `ClassNotFoundException`을 발생

## 클래스 로더가 지켜야 할 세가지 원칙

### 위임 원칙

클래스 로더는 리소스를 찾기 위해 상위 클래스 로더에게 책임을 위임한다.

### 가시 범위 원칙

하위 클래스 로더는 상위 클래스 로더가 로드한 클래스를 볼 수 있다.

### 유일성의 원칙

하위 클래스 로더가 상위 클래스 로더에게 로드한 클래스를 다시 로드하지 않는다.

## 동적 클래스 로딩

JVM은 모든 클래스에 대한 정보를 메서드 영역에 로딩하지 않는다.  
클래스 참조 시점에 JVM에 코드가 링크되고, 실제 런타인 시점에 로딩한다.

## Runtime Data Areas(메모리 구조)

- JVM이 읽어 들인 각종 타입 정보, 상수, 정적 변수 정보가 저장되는 영역이다.
- JIT 컴파일러가 번역한 기계어 코드를 캐싱하기 위한 메모리 공간으로도 활용한다.

## Runtime Data Areas 영역

- Method Area (메소드 영역)
- Heap
- Stack
- PC register (Program Counter Register)
- Native Method stack

## Method Area

- JVM이 읽어 들인 각종 타입 정보, 상수, 정적 변수 정보가 저장되는 영역
- JIT 컴파일러가 번역한 기계어 코드를 캐싱하기 위한 메모리 공간으로 활용

## Rutime constant pool (상수 풀)

- 클래스 파일에 포함된 정보 및 가종 리터럴, 심볼 참조가 저장되는 영역
- 클래스 로더가 클래스를 로드할 때 상기 정보들을 저장
- 동적으로 운영되며 런타임에 새로운 상수가 추가

> 해당 값들을 모든 쓰레드가 공유함

## Heap

- 가비지 컬렉터가 관리하는 메모리 영역으로 객체가 저장되는 공간
- 설정에 따라 크기를 조절할 수 있음
- 세대별 컬렉션 이론을 기반으로 설계 및 운영

## 세대별 컬렉션 이론 기초 가설

- 약한 세대 가설 : 대다수 객체는 일찍 죽는다.
- 강한 세대 가설 : 가비지 컬렉션 과정에서 살아남은 횟수가 늘어날수록 더 오래 살 가능성이 커진다.
- 세대 간 참조 가설 : 세대 간 참조의 개수는 같은 세대 안에서 참조보다 훨씬 적다.

## Heap과 세대 단위 컬렉션 이론

Heap 영역은 효율적인 Garbage Collection을 위해 크게 3가지 영역으로 구분된다.

- Young Generation
- Tenured(Old) Generation
- Permanent Generation

### Young Generation

새롭게 생성된 객체가 할당되는 영역이다.  
대부분 객체가 금방 Unreachable한 상태가 되기 때문에 많은 객체가 Young 영역에 생성되었다가 사라짐.  
Young 영역에 대한 가비지 컬렉션을 Minor GC라고 부른다.

### Tenured(Old) Generation

Young Generation에서 생존한 객체 중 오래된 인스턴스를 복사하여 저장하는 영역이다.  
Young영역보다 크게 할당되며 영역 크기가 큰 만큼 가비지는 적게 발생한다.  
Old 영역에 대한 가비지 컬렉션을 Major GC 또는 Full GC라고 부른다.

### Permanent Generation

ClassLoader에 의해 동적으로 로딩된 클래스의 메타데이터가 저장되는 영역  
이 정보들은 JVM 실행 도중에 변경되지 않으며, JVM 종료 시까지 유지

> Java 8 이후 **Metaspace로 대체**되어 **Heap영역에서 제외**되었다

### Permanent Generation의 문제점

PermGem은 JVM 내부에 고정된 크기의 메모리 공간이었으며 아래와 같은 문제가 자주 발생했다.

- 클래스를 과도하게 많이 로딩
- 동적 프록시를 자주 생성
- 재시작 없이 애플리케이션을 여러 번 redeploy하는 경우
- 적절한 크기를 조절하기 힘들었음

> 메모리 용량을 크게 잡는다면 OOM(`OutOfMemoryError`)이 발생  
> 메모리 용량을 작게 잡는다면 메모리 낭비

### Metaspace

- Perm 영역에서 저장하던 Class의 Meta 정보들이 이 영역에서 저장
- Native Memory 영역에 위치하며 JVM이 아닌 운영체제가 관리
- 클래스 메타데이터와 리플렉션을 이용하는 애플리케이션에서 사용하는 일부 메모리를 저장

> 클래스 메타데이터를 Native Memory에 저장하면서, JVM에서의 `OutOfMemoryError` 문제가 해결되었다.

## Stack (스택)

- 지역변수 테이블, 피연산자 스택, 메서드 반환 값 등을 저장
- 보통 지역변수 테이블을 스택으로 지칭
- 지역 변수 테이블은 슬롯으로 이루어지며 기본형 변수 하나가 슬록 한 개를 사용
- Java 스택의 크기는 메모리 용량이 아니라 슬롯의 개수
- JVM이 허용하는 스택의 크기를 초과할 경우 `StackOverflowError` 에러 발생

## PC Register

> Stack, Native Method Stack과 함께 쓰레드가 생성될 때 각 쓰레드마다 할당되는 영역으로,  
> 현재 수행중인 JVM의 명령어 주소를 저장한다

## Native Method Stack

> Native 언어(C/C++, 어셈블리)로 작성된 코드를 실행하기 위한 메모리 영역

# 출처

[널널한 개발자님 인프런 강의](https://www.inflearn.com/course/%EB%8F%85%ED%95%98%EA%B2%8C-%EC%8B%9C%EC%9E%91%ED%95%98%EB%8A%94-java-part2/dashboard)

[https://velog.io/@impala/JAVA-JVM-Runtime-Data-Area](https://velog.io/@impala/JAVA-JVM-Runtime-Data-Area)