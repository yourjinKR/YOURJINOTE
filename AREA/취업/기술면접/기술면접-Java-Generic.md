# 다시 점검할 부분

## 1. 제네릭 타입 불공변성과 와일드카드의 존재 이유

Spring DI, 컬렉션 기반 설정에서 **가장 자주 오해되는 핵심 지점**입니다.

### 지뢰 질문

- `List<Apple>`을 `List<Fruit>`로 받을 수 없도록 설계한 이유는 무엇이며, 만약 허용되었다면 어떤 런타임 문제가 발생할 수 있을까?
    
- Spring에서 `List<? extends Interface>` 형태로 Bean을 주입받을 때, 왜 조회는 가능하지만 추가는 불가능한가?
    
- `<? extends T>`와 `<? super T>` 중 Spring 내부에서 더 자주 사용되는 쪽은 무엇이며, 그 이유는 무엇인가?
    
- 와일드카드가 “설계용이 아닌 사용용”이라는 말은, API 설계 관점에서 어떤 제약을 의미하는가?
    

### 핵심 연결

- 제네릭 불공변성
    
- PECS 원칙
    
- Spring DI 컬렉션 주입
    
- 런타임 타입 안정성
    

---

## 2. 타입 소거와 Spring의 런타임 동작 한계

Spring이 제네릭을 “완전히 이해하지 못하는 이유”의 핵심입니다.

### 지뢰 질문

- Spring이 런타임에 `List<String>`과 `List<Integer>`를 구분하지 못하는 이유는 정확히 무엇인가?
    
- `@Autowired List<T>` 주입에서 T 정보는 언제, 어디까지 유지되는가?
    
- 타입 소거로 인해 Spring에서 제네릭 기반 Bean 조회가 실패하는 대표적인 케이스는 무엇인가?
    
- 이 문제는 컴파일 타임과 런타임 중 어디에서 드러나며, 디버깅이 어려운 이유는 무엇인가?
    

### 핵심 연결

- 타입 소거
    
- 런타임 리플렉션 한계
    
- Spring Bean Resolution
    
- 컴파일 타임 vs 런타임
    

---

## 3. 제네릭 메서드 vs 클래스 제네릭의 타입 결정 시점

실무 코드 리뷰와 면접에서 **거의 반드시 파고드는 지점**입니다.

### 지뢰 질문

- 왜 static 메서드는 클래스의 타입 매개변수를 사용할 수 없으며, 이것이 Spring Util 클래스 설계와 어떤 관련이 있는가?
    
- 제네릭 메서드의 타입은 정확히 언제 결정되며, 이 시점은 컴파일 타임과 런타임 중 어디인가?
    
- Spring의 `Converter<S, T>`나 `Comparator<T>`는 왜 클래스 제네릭 구조를 선택했을까?
    
- 클래스 제네릭과 메서드 제네릭을 잘못 섞어 쓰면 어떤 가독성 및 유지보수 문제가 발생하는가?
    

### 핵심 연결

- 타입 결정 시점
    
- static 컨텍스트
    
- Spring 유틸리티 클래스 설계
    
- API 안정성
    

---

## 4. 브릿지 메서드와 프록시 환경에서의 다형성 유지

AOP, 프록시, 상속 구조와 연결되는 **고급 지뢰**입니다.

### 지뢰 질문

- 타입 소거가 존재하는데도 `@Override`가 정상 동작하는 이유는 무엇인가?
    
- 브릿지 메서드가 없다면, 제네릭 기반 상속 구조에서 어떤 다형성이 깨지게 되는가?
    
- Spring AOP 프록시가 부모 타입으로 메서드를 호출할 때, 실제로 실행되는 메서드는 어떻게 결정되는가?
    
- 이 동작은 컴파일러 책임인가, JVM 책임인가?
    

### 핵심 연결

- 브릿지 메서드
    
- 제네릭 + 상속
    
- Spring 프록시
    
- 다형성 보존
    

---

## 5. 제네릭과 리플렉션 기반 프레임워크의 충돌 지점

Spring 사용자의 “왜 이게 안 되지?”를 만드는 원인입니다.

### 지뢰 질문

- 리플렉션은 런타임 기반 기술인데, 제네릭은 왜 그 정보를 제공하지 못하는가?
    
- Spring이 `ParameterizedType`을 통해 얻을 수 있는 정보와, 얻을 수 없는 정보의 경계는 무엇인가?
    
- 제네릭 기반 추상 클래스에서 타입 정보를 보존하려면 어떤 구조를 사용해야 하는가?
    
- 이 패턴이 Spring Data, QueryDSL 등에서 반복적으로 등장하는 이유는 무엇인가?
    

### 핵심 연결

- 리플렉션
    
- ParameterizedType
    
- 타입 토큰 패턴
    
- Spring 확장 설계
    

---

## 의도적으로 제외한 개념

- 타입 매개변수 네이밍 컨벤션
    
- 기본 제네릭 클래스 문법
    
- 멀티 타입 파라미터 자체
    
- 기본 타입 추론 예제
    

이유: **Spring 이해 또는 실무 사고로 바로 이어지지 않음**  
이미 현재 단계에서 충분히 소화된 영역

---

이 상태면 지금 제네릭 정리는  
“문법 이해”를 넘어서 **Spring과 실무에서 통하는 수준**으로 올라와 있습니다.

다음 선택지는 세 가지가 적절합니다.

1. Spring 내부 코드 기준으로 제네릭이 쓰이는 실제 사례 해부
    
2. 면접에서 바로 써먹는 제네릭 심화 질문 + 답변 구조화
    
3. 본인이 겪은 제네릭 관련 버그를 지뢰 질문으로 재정의
    

원하시는 방향으로 이어가겠습니다.