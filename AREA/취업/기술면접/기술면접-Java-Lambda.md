아래는 **작성하신 정리 내용 전체 중에서**  
가이드라인에 따라 **지뢰 질문이 반드시 필요한 개념만 선별**한 결과입니다.

람다 문법 자체, 기본 함수형 인터페이스 나열 등은 **암기·숙련 영역**이므로 제외했고,  
**Spring 내부 동작 / 실무 버그 / 런타임 사고**로 이어질 수 있는 지점만 골랐습니다.

---

# 다시 점검할 부분

## 1. 람다는 “메서드”가 아니라 “객체”라는 사실을 정확히 이해하고 있는가?

### 질문

- 아래 코드에서 `supplier`는 언제 생성되는 객체이며, 몇 번 생성되는가?
    
    ```java
    Supplier<Integer> supplier = () -> expensive();
    ```
    
- 람다식은 호출될 때마다 새 객체가 만들어지는가, 아니면 한 번만 만들어지는가?
    
- 같은 람다식을 두 번 선언하면 `==` 비교 결과는 항상 같을까?
    

### 핵심 연결

- 함수형 인터페이스
    
- JVM의 람다 구현 방식
    
- Spring Bean 스코프 및 싱글톤과의 오해 지점
    

---

## 2. 람다에서 외부 변수를 캡처할 때 왜 “사실상 final” 제약이 생기는가?

### 질문

- 다음 코드는 왜 컴파일 에러가 발생하는가?
    
    ```java
    int count = 0;
    Runnable r = () -> System.out.println(count++);
    ```
    
- 이 제약은 컴파일 타임 제약인가, 런타임 제약인가?
    
- 만약 람다가 내부 클래스로 구현되었다면, 이 제약이 없을 경우 어떤 문제가 생길 수 있을까?
    

### 핵심 연결

- 스택 변수 캡처
    
- 익명 클래스 vs 람다의 차이
    
- 동시성 안전성 사고
    

---

## 3. 람다를 사용한 예외 처리 패턴은 왜 조심해야 하는가?

### 질문

- `Supplier<T>` 내부에서 체크 예외를 던질 수 없는 이유는 무엇인가?
    
- 아래 구조는 예외 원인을 디버깅하기에 어떤 단점을 가지는가?
    
    ```java
    static <T> T repeatRun(Supplier<T> supplier) {
        while (true) {
            try {
                return supplier.get();
            } catch (Exception e) {
                System.out.println("에러 발생");
            }
        }
    }
    ```
    
- Spring 트랜잭션 내부에서 이 패턴을 사용하면 어떤 문제가 발생할 수 있을까?
    

### 핵심 연결

- 체크 예외 vs 언체크 예외
    
- 트랜잭션 롤백 조건
    
- 예외 삼키기 문제
    

---

## 4. 메서드 참조는 “항상” 람다의 단순 치환인가?

### 질문

- 다음 두 코드는 항상 동일한 의미를 가질까?
    
    ```java
    list.forEach(s -> service.process(s));
    list.forEach(service::process);
    ```
    
- 메서드 오버로딩이 존재할 때, 컴파일러는 어떤 기준으로 메서드를 선택하는가?
    
- 잘못된 메서드 참조가 선택되면 오류는 컴파일 타임에 발생할까, 런타임에 발생할까?
    

### 핵심 연결

- 타입 추론
    
- 오버로딩 해석 규칙
    
- 컴파일 타임 바인딩
    

---

## 5. 컬렉션 + 람다 조합은 언제 “안전하지 않게” 동작하는가?

### 질문

- `forEach` 내부에서 컬렉션을 수정하면 왜 예외가 발생하는가?
    
    ```java
    list.forEach(e -> {
        if (e.isBad()) list.remove(e);
    });
    ```
    
- 같은 로직을 `removeIf`로 바꾸면 안전한 이유는 무엇인가?
    
- 이 차이는 람다 때문인가, 컬렉션 구현체 때문인가?
    

### 핵심 연결

- Iterator 내부 동작
    
- ConcurrentModificationException
    
- 컬렉션 API 설계 의도
    

---

## 정리 판단 요약

- 람다 문법 자체: 지뢰 질문 불필요
    
- 함수형 인터페이스 종류 나열: 지뢰 질문 불필요
    
- **람다의 정체성 / 캡처 / 예외 / 메서드 참조 / 컬렉션 결합 지점**: 필수 지뢰 영역
    

지금 단계에서는 **이 정도만 정확히 설명 가능하면**  
Spring, Stream, 트랜잭션, 실무 코드 리뷰에서 **람다 관련 사고는 거의 안 납니다**.

다음으로 이어가면 좋은 지뢰 주제는  
“Stream은 왜 중간 연산과 최종 연산으로 나뉘었는가?” 입니다.