# 다시 점검할 부분

### 1. “어노테이션은 주석처럼 언어에 영향을 미치지 않는다”는 말은 정확한가?

#### 질문

- 어노테이션이 **컴파일 결과(.class)** 에 영향을 미치는 경우는 언제인가?
- `@Override`는 왜 런타임이 아니라 **컴파일 타임에만** 의미가 있을까?
- Spring에서 어노테이션이 실제 동작을 바꾸는 이유는 무엇인가?

#### 핵심 연결

- 컴파일러
- 바이트코드
- Spring의 리플렉션 기반 처리

### 2. @Retention 정책은 왜 Spring에서 핵심인가?

#### 질문

- Spring의 `@Component`, `@Service`는 왜 반드시 `RUNTIME` 이어야 할까?
- 만약 `SOURCE`나 `CLASS`라면 Spring은 이 어노테이션을 인식할 수 있을까?
- `CLASS`와 `RUNTIME`의 실제 차이는 JVM 입장에서 무엇인가?

#### 핵심 연결

- 리플렉션
- Bean 스캔
- 런타임 메타데이터

### 3. 어노테이션 요소는 왜 그렇게 제한적인 타입만 허용할까?

#### 질문

- 왜 어노테이션 요소에는 `List`, `Map` 같은 타입을 쓸 수 없을까?
- 왜 `null`을 기본값으로 둘 수 없을까?
- 이 제약은 **JVM 설계 문제일까, 컴파일러 문제일까?**

#### 핵심 연결

- 어노테이션의 내부 표현
- 컴파일 타임 상수
- 클래스 메타데이터 구조

### 4. 어노테이션에 디폴트 메서드가 없는 이유는 무엇인가?

#### 질문

- 어노테이션이 인터페이스처럼 보이는데, 왜 디폴트 메서드는 허용되지 않을까?
- 어노테이션 요소가 “메서드”처럼 보이는 이유는 무엇일까?
- JVM은 어노테이션을 **객체로 생성할까, 메타데이터로 취급할까?**

#### 핵심 연결

- 어노테이션은 실행 로직이 아니라 **값의 집합**
- 프록시 기반 구현

### 5. @Inherited는 왜 인터페이스에는 적용되지 않을까?

#### 질문

- `@Inherited`는 왜 **클래스 상속에만** 적용될까?
- Spring에서 인터페이스 기반 설계가 많은데, 이 제한은 어떤 의미를 가질까?
- 실제 Spring 어노테이션 중 `@Inherited`가 붙어 있는 이유는 무엇일까?
    

#### 핵심 연결

- 클래스 상속 vs 인터페이스 구현
- 프록시 구조
- 메타데이터 탐색 전략

### 6. @Repeatable은 왜 “컨테이너 어노테이션”이 필요할까?

#### 질문

- 왜 JVM은 어노테이션 배열을 직접 지원하지 않을까?
- `@Repeatable`은 문법적 설탕인가, 구조적 제약의 결과인가?
- Spring은 반복 어노테이션을 내부에서 어떻게 읽을까?

#### 핵심 연결

- 컴파일 타임 변환
- 리플렉션 API
- Spring의 메타 어노테이션 처리

### 7. Spring은 어노테이션을 “언제” 읽는가? ⭐

#### 질문

- Spring은 어노테이션을 애플리케이션 시작 중 **어느 시점에** 읽을까?
- Bean 생성 전일까, 후일까?
- 프록시 객체에는 원래 클래스의 어노테이션이 남아 있을까?

#### 핵심 연결

- ApplicationContext 초기화
- BeanDefinition
- 프록시와 타겟 클래스
