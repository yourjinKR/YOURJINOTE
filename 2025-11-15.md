- [x] 벨로그 작성


# jsp 화면 구성
```
src
 └─ main
     ├─ webapp
     │   └─ WEB-INF
     │       └─ views
     │           ├─ common
     │           │   ├─ header.jsp
     │           │   └─ footer.jsp
     │           ├─ quiz
     │           │   ├─ quiz-list.jsp
     │           │   └─ quiz-detail.jsp
     │           └─ user
     │               └─ login.jsp
     └─ resources
         └─ static
             ├─ css
             └─ js
```


페이지 컨트롤러와 index.jsp가 나오는 걸 확인함. 이제 전달한 데이터가 잘 보이는지 확인해보고 싶어
```kotlin
package com.woowacourse.wordcapsule.controller.quiz  
  
import com.woowacourse.wordcapsule.service.quiz.QuizRecordServiceInterface  
import org.springframework.data.domain.PageRequest  
import org.springframework.data.domain.Sort  
import org.springframework.stereotype.Controller  
import org.springframework.ui.Model  
import org.springframework.web.bind.annotation.GetMapping  
import org.springframework.web.bind.annotation.RequestMapping  
import org.springframework.web.bind.annotation.RequestParam  
  
@Controller  
@RequestMapping("/quiz")  
class QuizPageController(  
    private val quizRecordService: QuizRecordServiceInterface  
) {  
  
    @GetMapping  
    fun list(  
        @RequestParam(required = false) userId: Long?,  
        @RequestParam(defaultValue = "0") page: Int,  
        @RequestParam(defaultValue = "10") size: Int,  
        @RequestParam(defaultValue = "startedAt,desc") sort: String,  
        model: Model  
    ): String {  
        val sortDirection = if (sort.contains("desc")) Sort.Direction.DESC else Sort.Direction.ASC  
        val sortProperty = sort.split(",")[0]  
        val pageable = PageRequest.of(page, size, Sort.by(sortDirection, sortProperty))  
  
        val result = quizRecordService.getUserQuizRecordList(userId, pageable)  
  
        model.addAttribute("records", result.content)  
        model.addAttribute("page", result)  
        model.addAttribute("contentView", "/WEB-INF/views/content/record/record-list.jsp")  
        model.addAttribute("pageTitle", "퀴즈 기록 목록")  
  
        return "index"   // 레이아웃 JSP  
    }  
}
}
```

```html
<!doctype html>  
<html lang="kr">  
<head>  
    <meta charset="UTF-8">  
    <meta name="viewport"  
          content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">  
    <meta http-equiv="X-UA-Compatible" content="ie=edge">  
    <title>Document</title>  
</head>  
<body>  
    <h1>wordcapsule</h1>  
</body>  
</html>
```



# JSP 세팅

## 커스텀 에러 페이지
### 설정
```yaml
spring:  
  application:  
    name: wordCapsule  
  mvc:  
    view:  
      prefix: /WEB-INF/views/  
      suffix: .jsp  
  web:  
    resources:  
    # false로 설정 필요
      add-mappings: false
```

### GlobalViewControllerAdvice
커스텀 에러 페이지로 이동
```kotlin
package com.woowacourse.wordcapsule.config  
  
import org.springframework.web.bind.annotation.ControllerAdvice  
import org.springframework.web.bind.annotation.ExceptionHandler  
import jakarta.servlet.http.HttpServletRequest  
import org.springframework.http.HttpStatus  
import org.springframework.http.MediaType  
import org.springframework.web.servlet.NoHandlerFoundException  
  
// @ControllerAdvice 사용 (JSON을 반환하는 @RestControllerAdvice와 분리)  
@ControllerAdvice  
class GlobalViewControllerAdvice {  
  
    /**  
     * 특정 HTTP 상태 코드를 반환하는 예외를 처리합니다.     * (예: EntityNotFoundException -> ResponseCode.NOT_FOUND로 매핑되는 경우)     */    @ExceptionHandler(Exception::class, produces = [MediaType.TEXT_HTML_VALUE]) // catch all (가장 일반적인 예외)  
    fun handleGeneralViewException(  
        ex: Exception,  
        request: HttpServletRequest  
    ): String {  
        // API 요청이 아닌 'text/html'을 기대하는 요청만 여기서 처리되도록 가정  
  
        // 예외 종류에 따라 HTTP 상태 코드 결정 (기본 500)        val status = if (ex is IllegalAccessException) {  
            HttpStatus.FORBIDDEN  
        } else {  
            HttpStatus.INTERNAL_SERVER_ERROR // 500  
        }  
  
        request.setAttribute("statusCode", status.value())  
        request.setAttribute("errorMessage", status.reasonPhrase)  
        request.setAttribute("exception", ex.message)  
  
        // 파일 구조: /WEB-INF/views/content/error/error.jsp  
        // 따라서 반환 값은 'content/error/error'        return "content/error/error"  
    }  
  
    // Spring MVC에서 처리할 수 없는 404 (Controller/Handler를 찾지 못했을 때) 처리  
    // 이는 @ExceptionHandler로 직접 처리하기 어려우며, Spring Boot의 기본 메커니즘을 활용하는 것이 일반적입니다.  
    // 404 Not Found를 명시적으로 JSP로 처리하고 싶다면, NoHandlerFoundException을 사용해볼 수 있습니다.    // 하지만 이 예외가 발생하려면 application.yml에 spring.web.servlet.throw-exception-if-no-handler-found: true 설정이 필요합니다.    @ExceptionHandler(NoHandlerFoundException::class, produces = [MediaType.TEXT_HTML_VALUE])  
    fun handleNotFoundError(  
        request: HttpServletRequest  
    ): String {  
        request.setAttribute("statusCode", HttpStatus.NOT_FOUND.value())  
        request.setAttribute("errorMessage", HttpStatus.NOT_FOUND.reasonPhrase)  
        request.setAttribute("exception", "요청하신 페이지를 찾을 수 없습니다.")  
  
        // 파일 구조: /WEB-INF/views/content/error/404.jsp  
        // 404 전용 페이지가 있다면 해당 뷰를 반환합니다.        return "content/error/404"  
    }  
}
```

추가로 아래와 같이 기존 글로벌 컨트롤러에 produces를 명시한다
여기서 중요한 점은 아래와 같이 나머지 에러 처리에 대한 로직은 제외해야 된다.
```kotlin
//    /**  
//     * 기타 모든 예외에 대한 기본 처리  
//     */  
//    @ExceptionHandler(Exception::class, produces = [MediaType.APPLICATION_JSON_VALUE])  
//    fun handleGenericException(  
//        ex: Exception  
//    ): ResponseEntity<ErrorResponse> {  
//        val errorResponse = ErrorResponse.of(ResponseCode.INTERNAL_ERROR, ex)  
//        return ResponseEntity.status(ResponseCode.INTERNAL_ERROR.httpStatus).body(errorResponse)  
//    }  
```

```kotlin
package com.woowacourse.wordcapsule.config  
  
import com.woowacourse.wordcapsule.dto.common.ErrorDetailResponse  
import com.woowacourse.wordcapsule.dto.common.ErrorResponse  
import com.woowacourse.wordcapsule.dto.common.ResponseCode  
import jakarta.persistence.EntityNotFoundException  
import org.springframework.dao.DataIntegrityViolationException  
import org.springframework.http.MediaType  
import org.springframework.http.ResponseEntity  
import org.springframework.http.converter.HttpMessageNotReadableException  
import org.springframework.web.bind.MethodArgumentNotValidException  
import org.springframework.web.bind.annotation.ExceptionHandler  
import org.springframework.web.bind.annotation.RestControllerAdvice  
  
/**  
 * 전역 예외 처리를 위한 컨트롤러 어드바이스 * 모든 컨트롤러에서 발생하는 예외를 일관된 형태로 처리 */@RestControllerAdvice  
class GlobalExceptionHandler {  
  
    /**  
     * 요청 데이터 검증 실패 시 처리     * @Valid 어노테이션으로 인한 검증 오류를 처리  
     */    @ExceptionHandler(MethodArgumentNotValidException::class, produces = [MediaType.APPLICATION_JSON_VALUE])  
    fun handleValidationException(  
        ex: MethodArgumentNotValidException  
    ): ResponseEntity<ErrorResponse> {  
        val errors = ex.bindingResult.fieldErrors.map { fieldError ->  
            ErrorDetailResponse(  
                field = fieldError.field,  
                value = fieldError.rejectedValue,  
                reason = fieldError.defaultMessage ?: "검증 실패"  
            )  
        }  
  
        val errorResponse = ErrorResponse.of(ResponseCode.VALIDATION_FAILED, errors)  
        return ResponseEntity.status(ResponseCode.VALIDATION_FAILED.httpStatus).body(errorResponse)  
    }  
  
    /**  
     * 엔티티를 찾을 수 없을 때 처리     */    @ExceptionHandler(EntityNotFoundException::class, produces = [MediaType.APPLICATION_JSON_VALUE])  
    fun handleEntityNotFoundException(  
        ex: EntityNotFoundException  
    ): ResponseEntity<ErrorResponse> {  
        val errorResponse = if (ex.message.isNullOrBlank()) {  
            ErrorResponse.of(ResponseCode.NOT_FOUND)  
        } else {  
            ErrorResponse.of(ResponseCode.NOT_FOUND, ex.message!!)  
        }  
  
        return ResponseEntity.status(ResponseCode.NOT_FOUND.httpStatus).body(errorResponse)  
    }  
  
    /**  
     * 데이터베이스 제약조건 위반 시 처리     */    @ExceptionHandler(DataIntegrityViolationException::class, produces = [MediaType.APPLICATION_JSON_VALUE])  
    fun handleDataIntegrityViolationException(  
        ex: DataIntegrityViolationException  
    ): ResponseEntity<ErrorResponse> {  
        val errorResponse = ErrorResponse.of(ResponseCode.DATABASE_ERROR, ex)  
        return ResponseEntity.status(ResponseCode.DATABASE_ERROR.httpStatus).body(errorResponse)  
    }  
  
    /**  
     * JSON 파싱 에러 처리     */    @ExceptionHandler(HttpMessageNotReadableException::class, produces = [MediaType.APPLICATION_JSON_VALUE])  
    fun handleHttpMessageNotReadableException(  
        ex: HttpMessageNotReadableException  
    ): ResponseEntity<ErrorResponse> {  
        val errorResponse = ErrorResponse.of(ResponseCode.BAD_REQUEST, "잘못된 형식의 JSON 요청입니다")  
        return ResponseEntity.status(ResponseCode.BAD_REQUEST.httpStatus).body(errorResponse)  
    }  
  
//    /**  
//     * 기타 모든 예외에 대한 기본 처리  
//     */  
//    @ExceptionHandler(Exception::class, produces = [MediaType.APPLICATION_JSON_VALUE])  
//    fun handleGenericException(  
//        ex: Exception  
//    ): ResponseEntity<ErrorResponse> {  
//        val errorResponse = ErrorResponse.of(ResponseCode.INTERNAL_ERROR, ex)  
//        return ResponseEntity.status(ResponseCode.INTERNAL_ERROR.httpStatus).body(errorResponse)  
//    }  
  
    /**  
     * 접근 권한 없음 예외 처리     */    @ExceptionHandler(IllegalAccessException::class, produces = [MediaType.APPLICATION_JSON_VALUE])  
    fun handleIllegalAccessException(  
        ex: IllegalAccessException  
    ): ResponseEntity<ErrorResponse> {  
        val errorResponse = ErrorResponse.of(ResponseCode.FORBIDDEN, ex)  
        return ResponseEntity.status(ResponseCode.FORBIDDEN.httpStatus).body(errorResponse)  
    }  
}
```