
# 리드미 작성
## 트러블 슈팅


## 회고
### 잘한 점
- 반복적으로 사용되는 로직을 유틸성 있게 전환하도록 노력한 점
- 통계 응답를 직관적인 데이터 구조로 설계 및 구현한 점 (`enum` 활용)
### 어려웠던 점
- 미구현된 엔티티에 대한 연관관계 다루기
### 협업에서 아쉬웠던 부분과 개선 방법
- 개발 시작 전 엔티티 뼈대 코드의 부재 → 엔티티 연관관계 매핑 과정에서 어려움을 겪음
- PR 과정에서 default branch와의 충돌 → `fetch` & `merge`, `checkout`, `merge` 과정 준수 

# 개인적 기록
## 트러블 슈팅

## 회고
통계 응답값을 직관적인 데이터 구조로 잘 설계한거 같다.

### branch 환경에서의 협업
2번의 웹개발 프로젝트 경험이 있으나  
### JPA 연관관계 상황에서 협업
JPA에 아직 익숙하지 않을 뿐더러 협업 프로젝트에서는 처음이기에 어려움을 겪었다.
그 중에서도 가장 어려웠던 점은 엔티티를 설계할때 아직 다른 엔티티가 완성되어 있지 않아 연관관계 매핑을 하지 못한 점이다.
대신 해당 엔티티의 `id`(pk)를 프로퍼티로 삼아 임시방편으로 구현했다.
그로 인해 이미 완성한 변경점으로 인해 다시 수정하는 번거로움이 있었다. 만약 JPA를 사용한 협업을 다시 한번 더 진행하게 된다면 도메인을 먼저 설계 후 진행하는 것이 좋을거 같다.

**원래 완성되어야 할 엔티티**
```kotlin
@Entity
@Table(name = "quiz_records")
@EntityListeners(AuditingEntityListener::class)
open class QuizRecord(
    @Id @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = "record_id", nullable = false)
    val id: Long = 0L,

    @ManyToOne(fetch = FetchType.LAZY, optional = false)
    @JoinColumn(name = "user_id", nullable = false)
    val user: User,

    @ManyToOne(fetch = FetchType.LAZY, optional = false)
    @JoinColumn(name = "config_id", nullable = false)
    val config: QuizConfig,
    
    // 생략...
}
```


# 정리
## JPA 연관관계 협업 경험 및 개선점

**[경험한 문제]** 
프로젝트 중 `QuizRecord` 엔티티를 구현하며 JPA 연관관계를 매핑해야 했습니다. 하지만 `QuizRecord`가 의존하는 `User`나 `QuizConfig` 엔티티가 다른 팀원에 의해 아직 구현 중인 상황이었습니다. 이로 인해 `@ManyToOne` 같은 객체 연관관계를 즉시 매핑할 수 없었고, 임시방편으로 해당 엔티티의 `id` 값(Long 타입)을 직접 필드로 가지도록 구현했습니다.

**[문제 분석]** 
이 방식은 당장의 컴파일 오류는 해결해 주었지만, 결국 관련 엔티티가 완성되었을 때 연관관계 매핑 코드로 **다시 수정해야 하는 이중 작업(기술 부채)**을 유발했습니다.

근본적인 원인은 본격적인 코드 구현에 앞서, 팀 전체가 **데이터 모델(엔티티, 연관관계)에 대한 명확한 합의**가 부족했고, **작업 간의 의존관계를 명확히 정의하지 않았기** 때문이라고 생각합니다.

**[해결 및 배운 점]** 
다음 협업 프로젝트에서는 이 문제를 해결하기 위해 두 가지를 시도하겠습니다.

1. **(Domain-First)** 구현 시작 전, 팀원 전체가 참여하는 **도메인 모델링 세션**을 통해 **ERD(개체-관계 다이어그램)를 함께 설계하고 확정**하겠습니다.
2. **(Skeleton-First)** ERD가 확정되면, 각 엔티티의 세부 구현에 앞서 **`@Id` 필드만이라도 포함된 '스켈레톤 코드'를 먼저 작성해 공유**하는 프로세스를 도입하겠습니다.
3. **의존성을 파악**하여 업무 순서에 대한 명확성을 기반으로 작업하겠습니다. 

이렇게 하면 모든 팀원이 처음부터 `id` 원시 값이 아닌 **올바른 객체 타입으로 연관관계를 맺을 수 있어** 재작업을 원천적으로 방지하고 훨씬 효율적인 협업이 가능할 것입니다.