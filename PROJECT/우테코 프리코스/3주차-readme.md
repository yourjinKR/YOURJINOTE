# java-lotto-precourse  
  
요구사항 및 피드백을 기반를 상기시킨 후 프로그래밍 요구사항에 맞는 설계 시작  
  
## 피드백  
  
### 공통 피드백  
  
- 상세한 리드미 작성  
- 기능목록 업데이트  
- 변수명에 자료형을 사용 금지  
  
### 코드리뷰 피드백  
  
- 계층간 의존성 고려하여 개발  
- 각각의 클래스가 어떤 속성인지 다시 한번 더 생각  
  
## 이번 주차의 도전  
  
- 단위 테스트를 병행하며 개발  
- 도메인 영역 세분화  
  - mapper  
  - repository  
- DI 활용  
  
## 고민  
  
### 당첨번호와 보너스번호  
  
당첨 번호 추첨 시 중복되지 않는 숫자 6개와 보너스 번호 1개를 뽑는다.  
  
```prolog  
8개를 구매했습니다.  
[8, 21, 23, 41, 42, 43] [3, 5, 11, 16, 32, 38] [7, 11, 16, 35, 36, 44] [1, 8, 11, 31, 41, 42] [13, 14, 16, 38, 42, 45] [7, 11, 30, 40, 42, 43] [2, 13, 22, 32, 38, 45] [1, 3, 5, 14, 22, 45]  
```  
  
내가 알고 있는 복권은 아래와 같은 개념으로 알고 있기에 조금 헷갈린다  
> "일반 숫자 6개" + "보너스 숫자 1개" = "총 숫자 7개"  
  
해당 문제에서는 아래와 같은 개념인듯 하다  
> "중복되지 않는 숫자 6개" + "갯수에 포함되지 않는 보너스 번호 1개" = "총 숫자 6개"  
  
### 사용자에게 값을 다시 요청하는 방법  
  
> 사용자가 잘못된 값을 입력할 경우`IllegalArgumentException`을 발생시키고, "[ERROR]"로 시작하는 에러 메시지를 출력 후 그 부분부터 입력을 다시 받는다.  
> - `Exception`이 아닌`IllegalArgumentException`,`IllegalStateException`등과 같은 명확한 유형을 처리한다.  
  
#### 사용자가 잘못된 값을 입력할 경우는 다시 해당 값을 받아야 한다라?  
  
- 그렇다면 기존에 입력된 값들의 상태가 어딘가 저장되어야 한다?  
- 로또 번호 생성과 같은 경우는 비지니스 로직이기에 `View`에서 일어나면 안됨  
  그렇게 된다면 view와 model 간 다수의 통신으로 진행  
- 단 한번의 요청과 응답이 아님  
  
> 입력값 요청 -> 입력값 전송 -> 입력값 검증 -> 재전송 요청 -> 입력값 재요청   
  
#### 입력값 검증  
  
##### 구매 금액 입력  
  
- int로 파싱할 수 있는가?  
- 1000 단위인가?  
  
##### 당첨 번호 입력  
  
- 구분자로 split 후 int형 리스트로 파싱 가능한가?  
- 리스트의 크기가 6인가?  
- 각각의 번호가 1~45 사이에 존재하는 숫자인가?  
  
##### 보너스 번호 입력  
  
- int로 파싱할 수 있는가?  
- 번호가 1~45 사이에 존재하는 숫자인가?  
  
정리하자면 예외는 이와 같은 시점에서 발생함  
  
- 데이터 파싱  
- 객체 생성시 (혹은 `LottoRule`에 기반하여)  
  
### 로또 규칙을 추상화  
  
로또 규칙과는 별개로 유연한 코드를 작성하고 싶었음.  
로또 규칙이 당첨 규칙을 만듦  
  
#### 로또 공통규칙 파악  
  
- 모든 로또는 당첨에 대한 기준과 그에 대한 보상이 존재한다.  
  
### 당첨 규칙  
  
당첨에 대한 기준을 충족시 주어지는 보상이 있다.  
  
그렇다면 특정 영역에서 다수의 당첨 규칙과 다수의 로또번호를 알고 있어야 하며  
이를 매핑하는 과정을 거치면 자연스레 당첨에 대한 결과를 알 수 있음  
  
## 예외 처리  
  
### 예외 상황  
  
- 로또 번호의 숫자가 1~45가 아닐 경우  
- 로또 발행시 중복되는 숫자가 있을 경우  
- 보너스 번호의 숫자가 1~45가 아닐 경우  
- 잘못된 로또 가격을 제시할 경우 (1000으로 나눴을 때 나머지가 있는 값)  
- 당첨 번호를 6개 이상 제시할 경우  
  
## 도메인 설계  
  
### 프로그램 동작 흐름 나열  
  
1. 금액을 받음  
    1. `Integer money`로 전달  
2. 금액만큼 로또를 생성 및 출력  
    1. `List<Lotto>`가 필요  
3. 당첨번호와 보너스 번호를 받음  
    1. `List<Integer>`와 `Integer`로 전달  
4. 당첨을 계산  
    1. `List<Integer>`와 `Integer`를 기반으로 계산  
   5. 당첨규칙 객체들이 필요할듯  
        1. `{score : 3, bonus : false, price : 5000}`  
    3. 담청번호와 보너스 번호를 로또에게 전달 후 결과 반환  
        1. `{score : 3, bonus : false}`  
    4. 당첨규칙 객체와 로또의 결과를 매칭  
   6. 최종적으로 아래와 같은 형식으로 응답값 전달  
        1. `{score : 3, bonus : false, price : 5000, lottos : List.of(l1, l2...)}`  
        2. `float : 62.5`  
7. 당첨표와 수익률을 계산  
  
그렇다면 로또 리스트와 당첨규칙 리스트의 매핑 과정이 중요할듯함  
  
### 로또 요청값  
  
구입 금액을 기반으로 로또 발생 수를 전달하기 위한 DTO  
  
- 구입금액  
  
### Lotto (기본으로 제공된 클래스)  
  
- 숫자 List를 가짐  
- List의 사이즈 검증  
- List 내 숫자가 1~45 사이인지 검증  
- 중복숫자가 있는지 검증  
- 정적 팩토리 (랜덤 숫자 생성기를 받고 내부에서 생성)  
- 당첨 번호와 보너스 번호를 받고 비교값 계산 후 리턴 `{score : 3, bonus : true}`  
  
### 로또 발행 결과  
  
- 구입금액만큼 로또 객체를 생성 후 List에 저장  
- 그리고 로또 번호들을 출력하기 위해 View에 전달하여 출력하기 위함  
  
### 로또 당첨 요청값  
  
- 당첨번호, 보너스 번호와 로또 발행 결과를 알고 있음  
  
### 당첨 규칙  
  
당첨금에 대한 규칙을 별개의 객체로 관리  
  
- 점수, 보너스 일치 여부, 금액을 갖는다  
  
### 로또 규칙  
  
- 로또번호  
  - 최소번호  
  - 최대번호  
- 1회당 가격  
- 당첨 규칙 리스트  
  
## 구현 기능  
  
#### InputView  
  
- [x] 금액 요청문 출력  
- [x] 금액 입력값 타입 변환  
- [x] 당첨번호 요청문 출력  
- [x] 보너스번호 요청문 출력  
  
#### OutputView  
  
- [x] 금액만큼 발행된 로또들 출력  
- [x] 당첨규칙 및 일치한 수 출력  
- [x] 수익률 출력  
  
#### LottoConfig  
  
> 로또 설정값 관리  
  
#### AppConfig  
  
> 각 계층 생성  
  
#### ErrorMessage  
  
> 일괄된 양식으로 예외 메세지를 전달  
  
- [x] ENUM으로 에러 메세지를 한곳에서 관리  
- [x] 예외메세지 공통 헤더 필드  
  
#### PlayRule  
  
> 해당 로또 게임의 가격, 추첨 방식, 당첨 기준들을 관리  
  
- [x] 당첨기준을 `Map<점수,<당첨기준>>`와 같은 형태로 매핑  
- [x] 생성자에서 `List<Winning>`을 `Map<Integer, List<Winning>>`로 변환하여 저장  
- [x] 가격을 받으면 검증 및 뽑을 수 있는 기회 반환  
- [x] 점수와 보너스 일치 여부를 기준으로 일치하는 당첨기준을 count-up  
- [x] 로또 리스트를 받아 총 수익률 계산  
  
#### Winning  
  
> 당첨 기준에 대한 정보를 갖는 객체  
  
- [x] 점수(맞춘 개수), 보너스 일치 여부, 당첨금, 해당 기준과 일치한 갯수 필드 생성자  
- [x] 일치하는 값일때 카운트 업  
  - [x] 점수(맞춘 갯수) 비교  
  - [x] 점수(맞춘 갯수)와 보너스 일치 여부 비교  
- [x] 해당 당첨기준의 총상금  
  
#### PickRule  
  
> 추첨 방식에 대한 정보를 갖는 객체  
  
- [X] 추첨 규칙 인터페이스  
- [X] 랜덤 숫자 뽑기 메소드  
- [X] 로또 추첨 규칙 구현 (`LottoPickRule`)  
  - [X] 검증 메서드  
  
#### Lotto  
  
> 각각의 로또 정보를 갖는 객체  
  
- [X] 리스트 사이즈 검증  
- [X] 리스트 내 이상값 검증  
- [X] 중복 숫자 검증  
- [x] 정적 팩토리 (게임 규칙을 기반으로 객체 생성함)  
- [x] 당첨번호와 비교  
- [x] 보너스번호 여부 비교  
  
#### WinningLotto extends Lotto  
  
> 당첨번호와 보너스번호 또한 객체로 관리  
  
- [x] 보너스 번호 검증  
  
#### LottoRepository  
  
> 로또 데이터 생성  
  
- [X] 숫자를 받으면 그만큼의 수를 가진 로또 리스트를 만듬  
- [X] 저장된 로또 객체들 불러오기  
  
#### LottoMapper  
  
> 객체와 DTO 매핑