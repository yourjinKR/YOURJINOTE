# 기초 학습
[Runtime Data Area](https://github.com/yourjinKR/YOURJINOTE/blob/ed3c1cf993816f0c026d5202925f025f78d8925d/RESOURCE/JAVA/%5BJava%5D%20Runtime%20Data%20Areas.md)
# 문제 풀이
[백준 단계별 풀이 : 문자열 일부분, 심화 1~5](https://github.com/yourjinKR/javaBasic/commit/386199bc85676c06115dfeb05a97bbbbb2d4c80e)
# 개인 프로젝트
[PR link](https://github.com/yourjinKR/fitsync2-backend/pulls?q=is%3Apr+is%3Aclosed)


---
# 개인 프로젝트
## 에러 발생 1 : 수정 API 구현 중
```
Caused by: org.hibernate.PersistentObjectException: Detached entity passed to persist: app.fitsync.domain.exercise.entity.ExerciseTarget
```

```
jpa Detached entity passed to persist
```

## 버그 픽스 : view detail 과정에서 데이터 매핑
![Pasted image 20251203205608](Pasted%20image%2020251203205608.png)
`target`이 2번씩 저장 매핑되어 전달 중

```sql
select  
    distinct e1_0.id,  
             e1_0.category,  
             e1_0.created_at,  
             e1_0.deleted_at,  
             e1_0.description,  
             e1_0.details,  
             e2_0.exercise_id,  
             e2_0.effect_type,  
             e1_0.hidden,  
             e1_0.name,  
             t1_0.exercise_id,  
             t1_0.id,  
             t1_0.body_detail_part_id,  
             bdp1_0.id,  
             bdp1_0.body_part_id,  
             bp1_0.id,  
             bp1_0.name,  
             bdp1_0.name,  
             t1_0.target_role,  
             e1_0.updated_at  
from  
    exercises e1_0  
        left join  
    exercise_targets t1_0  
    on e1_0.id=t1_0.exercise_id  
        left join  
    body_detail_parts bdp1_0  
    on bdp1_0.id=t1_0.body_detail_part_id  
        left join  
    body_parts bp1_0  
    on bp1_0.id=bdp1_0.body_part_id  
        left join  
    exercise_effects e2_0  
    on e1_0.id=e2_0.exercise_id  
where  
    e1_0.id=8;
```
sql문을 실행해보니 sql문 자체에서도 동일한 target 데이터가 2개씩 출력 중

![Pasted image 20251203205904](Pasted%20image%2020251203205904.png)

그렇다면 데이터 저장 과정에서의 문제라기 보다는 쿼리문의 문제임.

### 쿼리문 파악
직접 쿼리를 작성하며 테스트
```sql
select *  
from  
    exercises e  
        left join  
            exercise_targets t on e.id = t.exercise_id  
        left join  
            body_detail_parts bdp on t.body_detail_part_id = bdp.id  
        left join  
            body_parts bp on bdp.body_part_id = bp.id  
        left join  
            -- 여기서 effect의 수만큼 데이터 복사  
            exercise_effects ef on e.id = ef.exercise_id 
where e.id = 8;
```
exercise_id를 외래키로 갖고 있는 exercise_effect로 인해 effect의 갯수만큼 데이터의 행이 늘어나 같은 객체가 매핑됐던 것임.

### 해결 방법 1 : 매핑 과정에서 distinct() 추가
```java
/**  
 * 운동 정보 엔티티를 상세 조회 DTO로 매핑 <br>  
 * 내부 데이터 또한 toDto 메서드를 통해 매핑  
 * @param exercise 운동 정보 엔티티  
 * @return 운동 정보 상세 조회 DTO  
 */public ExerciseDetailResponse toDto(Exercise exercise) {  
  
    List<ExerciseTarget> targets = exercise.getTargets();  
    List<ExerciseTargetDetailResponse> exerciseTargetDetailResponses = targets.stream()  
            .map(this::toDto)  
            .distinct() // 한줄 추가  
            .toList();  
  
    return new ExerciseDetailResponse(  
            exercise.getId(),  
            exercise.getName(),  
            exercise.getCategory(),  
            exercise.getDescription(),  
            exercise.getDetails(),  
            exercise.isHidden(),  
            exerciseTargetDetailResponses,  
            exercise.getEffects()  
    );  
}
```
코드상으로 한줄만 추가하면 이를 해결 할 수 있다.
그러나 이는 데이터 매핑 과정을 수정하여 현재 중복 조인 문제를 해결한 것이 아닌 숨긴 것이다.


```java
    /**
     * 운동 정보 상세 조회를 위한 쿼리
     */
    @Query("SELECT DISTINCT e " +
            "FROM Exercise e " +
            "LEFT JOIN FETCH e.targets t " +
            "LEFT JOIN FETCH t.bodyDetailPart bd " +
            "LEFT JOIN FETCH bd.bodyPart bp " +
//            "LEFT JOIN FETCH e.effects " + // 삭제
            "WHERE e.id = :id")
    Optional<Exercise> findByIdWithDetails(@Param("id") Long id);
```
effect에 대한 조인을 삭제했고 2개의 쿼리로 데이터를 받아 매핑하도록 수정했다.

---
# 런타임 데이터 영역
## Gradle 환경에서 빌드 및 JVM 구조 보기 

### 빌드
```bash
# WSL 상에서 현재 디렉토리로 이동
cd /mnt/c/dev/study/javaBasic

# gradle 빌드 (wrapper 사용)
./gradlew clean build
```

### 클래스 파일에서 costant pool 보기
```bash
# 클래스 파일 경로 예시
ls build/classes/java/main/com/example/App.class

# class파일로 직접 보기
javap -v build/classes/java/main/com/example/App.class | sed -n '1,180p'
# 또는 classpath로 지정
javap -v -classpath build/classes/java/main com.example.App | sed -n '1,200p'

# 경로까지 이동 했다면
javap -v App.class
```

### 빌드 실패
![Pasted image 20251203184307](Pasted%20image%2020251203184307.png)

```bash
# 1) 같은 사용자의 Gradle 데몬 정지
./gradlew --stop

# 2) 현재 쉘의 작업 디렉터리가 build 내부인지 확인(만약 내부면 밖으로 이동)
pwd
cd ~   # 프로젝트 밖으로 이동

# 3) build 폴더 강삭제
rm -rf build

# 4) 다시 빌드
./gradlew clean build

```
빌드 실패시 build파일 삭제 후 다시 시도

![Pasted image 20251203200132](Pasted%20image%2020251203200132.png)


# 스택 (Stack)
