# 자바에서 다중 상속을 지원하지 않는 이유

자바에서는 "단순하고, 객체 지향적이며, 견고한" 언어가 목적이기에 다중 상속을 지원하지 않는다.  
이에 대해 자바의 대안은 [인터페이스](Java-인터페이스-Interface.md)이며 다중 구현을 허용하면서 유연성을 확보했다.

## 다이아몬드 문제

- **상황:** 클래스 B와 C가 모두 클래스 A를 상속받고, 클래스 D가 B와 C를 동시에 상속받는다고 가정해 봅시다.
    
- **충돌:** 만약 B와 C가 A의 `run()`이라는 메서드를 각자 다른 방식으로 재정의(Override)했다면, D 객체에서 `run()`을 호출했을 때 **B의 버전을 써야 할지 C의 버전을 써야 할지 모호해집니다.**
    
- **결과:** C++은 이를 해결하기 위해 복잡한 문법(가상 상속 등)을 도입했지만, 자바는 아예 다중 상속을 막음으로써 이 문제를 원천 차단했습니다.

## 설계의 단순화와 가독성

C++은 다중 상속을 지원하지만, 그로 인해 언어가 매우 복잡해졌습니다. 자바 설계자들은 C++의 복잡성을 제거하는 것을 목표로 삼았습니다.

- **학습 곡선:** 다중 상속을 관리하기 위한 `virtual inheritance` 같은 개념은 초보자가 이해하기 어렵습니다.
    
- **명확한 계층 구조:** 단일 상속은 "A는 B의 일종이다(is-a)"라는 관계를 명확하게 유지해 줍니다. 부모가 여럿이면 이 논리적 관계가 꼬이기 쉽습니다.

## 구현의 복잡성과 성능

객체 모델을 메모리에 배치할 때, 다중 상속은 단일 상속보다 훨씬 복잡한 구조를 가집니다.

- **메모리 오버헤드:** 객체 내에서 필드 위치를 계산하는 로직이 복잡해져 런타임 성능에 미세한 영향을 줄 수 있습니다.
    
- **JVM 최적화:** 단일 상속 구조는 JVM이 메서드 호출을 최적화(Virtual Method Table 관리 등)하기에 훨씬 유리합니다.

<br>

# 클래스와 인터에이스 중 우선 순위

```java
interface Runnable {
    default void run() { System.out.println("인터페이스가 달림"); }
}

class Dog {
    public void run() { System.out.println("개가 달림"); }
}
```

위와 같은 클래스와 인터에이스가 있고 아래와 같이 Chiwawa 객체를 선언한다면 어떻게 될까?  
자바에서는 `class`를 우선순위로 여기기에 `Runnable`의 `run()`은 무시되고 `Dog`의 `run()`이 실행된다.

```java
class Chiwawa extends Dog implements Runnable { }
```

