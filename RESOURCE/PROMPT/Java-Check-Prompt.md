## 요구사항

> “아래 가이드라인을 기준으로  
> 내가 정리한 개념 중  
> **지뢰 질문이 필요한 것만 선별**하고  
> 개념당 **3~5개의 지뢰 질문만** 만들어줘.  
> Spring 및 실무 연관성을 우선으로 판단해줘.”


## 내가 정리한 개념





> 만약 정리한 내용 없이 주제만 있을 경우에는 해당 주제에 대한 전반적인 개념들을 전부 정리했다는 가정 하에 진행.  혹은 어떠한 내용도 명시되지 않았을 경우에는 생각을 멈추고 다시 재질문하기 바람.

## 지뢰 질문 선정 가이드라인

### 1. 기본 원칙

- 모든 개념에 지뢰 질문을 만들지 않는다
    
- **Spring Framework 이해 또는 실무 안정성과 직접 연결되는 개념만 대상**으로 한다
    
- 지뢰 질문은 “정의 확인용”이 아니라 **이해 검증용**이어야 한다

- 질문지 작성시 **이모지와 구분선을 절대 사용해서는 안되며 작성 양식을 준수**한다.

---

### 2. 지뢰 질문 대상 개념 선정 기준

아래 기준 중 **2개 이상**에 해당하면 지뢰 질문을 만든다.

#### (1) Spring 내부에서 실제로 사용되는 자바 개념인가

- Bean 생성 및 생명주기
    
- DI / IoC
    
- AOP / 프록시
    
- 트랜잭션
    
- 리플렉션
    
- 컬렉션 기반 설정
    
- 애노테이션 처리
    

#### (2) 실무에서 잘못 쓰면 버그 또는 장애로 이어지는가

- equals / hashCode
    
- Comparable / Comparator
    
- 컬렉션 선택
    
- 불변 객체
    
- Optional
    
- 예외 전파 및 체크 예외
    
- null 처리
    

#### (3) 컴파일 시점과 런타임의 차이를 이해해야 하는가

- 제네릭 / 타입 소거
    
- 다형성
    
- 캐스팅
    
- 인터페이스 기반 설계
    
- 프록시 객체
    

#### (4) 면접에서 “한 단계 더” 파고드는 지점인가

- 인터페이스 vs 추상 클래스
    
- Enum vs 상수 클래스
    
- 싱글톤
    
- 객체 생명주기
    
- 동시성 기초
    

---

### 3. 지뢰 질문 작성 기준

지뢰 질문은 반드시 아래 조건을 만족해야 한다.

- 정의 암기로는 답할 수 없을 것
    
- “왜 그렇게 설계됐는가?” 또는 “언제 깨지는가?”를 묻는 질문일 것
    
- 가능하면 **짧은 코드 또는 한 줄 상황**으로 사고를 유도할 것
    
- 컴파일 타임 / 런타임 중 어디서 문제가 발생하는지 구분하게 만들 것
    

---

### 4. 지뢰 질문 수량 제한 규칙

- 개념 하나당 **3~5개 이하**
    
- Spring과의 연관성이 약한 개념은 **1~2개로 제한**
    
- 학습 피로도를 느끼면 즉시 중단하고 “핵심 질문 1개만” 남긴다
    

---

### 5. 학습 단계별 적용 규칙

#### 1단계: 자바 1회독

- 지뢰 질문 생성 최소화
    
- 개념의 “존재”와 “위치”만 파악
    

#### 2단계: Spring 학습 병행

- Spring에서 실제로 쓰이는 개념에만 지뢰 질문 적용
    
- 프록시, DI, 컬렉션, 제네릭 우선
    

#### 3단계: 실무 / 프로젝트 단계

- 실제로 겪은 문제를 지뢰 질문으로 재정의
    
- “왜 이 문제가 생겼는가?”를 질문 형태로 남김
    

---

### 6. 지뢰 질문의 목적 정의

지뢰 질문의 목적은 다음 중 하나 이상을 만족해야 한다.

- Spring 동작 원리를 설명할 수 있게 한다
    
- 실무에서 디버깅 가능한 사고 구조를 만든다
    
- 면접에서 깊이 있는 답변을 가능하게 한다
    

목적이 없는 지뢰 질문은 만들지 않는다.

---

### 7. 작성 양식

```markdown

# 다시 점검할 부분

## 1. “어노테이션은 주석처럼 언어에 영향을 미치지 않는다”는 말은 정확한가?

### 질문

- 어노테이션이 **컴파일 결과(.class)** 에 영향을 미치는 경우는 언제인가?
- `@Override`는 왜 런타임이 아니라 **컴파일 타임에만** 의미가 있을까?
- Spring에서 어노테이션이 실제 동작을 바꾸는 이유는 무엇인가?

### 핵심 연결

- 컴파일러
- 바이트코드
- Spring의 리플렉션 기반 처리

## 2. @Retention 정책은 왜 Spring에서 핵심인가?

### 질문

- Spring의 `@Component`, `@Service`는 왜 반드시 `RUNTIME` 이어야 할까?
- 만약 `SOURCE`나 `CLASS`라면 Spring은 이 어노테이션을 인식할 수 있을까?
- `CLASS`와 `RUNTIME`의 실제 차이는 JVM 입장에서 무엇인가?

### 핵심 연결

- 리플렉션
- Bean 스캔
- 런타임 메타데이터

```
