
# Stack

스택은 **LIFO** 원칙을 따르는 [추상 자료형](ADT-Abstract-Data-Type.md)이다.

## 특징

- LIFO (Last in First Out)
- 단일 접근 지점 : top 위치에서만 삽입/삭제 가능
- 중간 요소 접근 불가 : 임의 위치에 대한 조회, 수정, 삽입, 삭제가 허용되지 않음


## 종류

스택은 크게 두가지 범주로 나눌 수 있다.

- Register Stack
- Memory Stack

![Pasted image 20251219125842](../../GALLERY/Pasted%20image%2020251219125842.png)

레지스터 스택은 일반적으로 CPU의 메모리 위치를 가리키며, 스택의 최상위 영역에 있는 요소들의 주소를 저장한다.  

메모리 스택은 메모리 레지스터에 비해 많은 양의 데이터를 저장하는 메모리 위치를 지칭한다.  
메모리 레지스터의 스택 깊이는 가변적이다.

## 주요 연산

- `push()` : 스택의 맨 끝(top)에 요소를 삽입합니다.
- `pop()` : 스택이 비어 있지 않으면 스택의 맨 위에 있는 요소를 제거하고 반환합니다.
- `peek()` : 스택이 비어 있지 않으면 스택의 맨 위에 있는 요소를 제거하지 않고 반환합니다.
- `size()` : 스택에 있는 요소의 개수를 반환합니다.
- `isEmpty()` : 스택이 비어 있으면 true를 반환하고, 그렇지 않으면 false를 반환합니다.
- `isFull()` : 스택이 가득 찼으면 true를 반환하고, 그렇지 않으면 false를 반환합니다. 고정 용량 스택(예: 배열 기반 스택)에만 해당됩니다.

## 구현

스택은 주로 배열과 연결 리스트를 기반으로 구현된다.

### 배열 기반 스택

#### 구조

- 고정 크기 혹은 동적 배열을 이용해 연속된 메모리 공간에 데이터 저장
- top 인덱스 값만 증가 또는 감소시키며 push/pop 수행

#### 특징

- 인덱스 접근이 가능하지만 스택에서는 사용하지 않음
- 연속된 메모리 할당 필요
- 크기를 미리 결정해야 하며, 꽉 차면 재할당 필요(ArrayList처럼)

#### 장점

- 접근이 빠르고 캐시 친화적 (메모리 연속성)
- 구현이 매우 간단함
- push/pop이 상수 시간 O(1)로 안정적
- 메모리 오버헤드가 적음 (포인터가 없음)

#### 단점
1. **크기 제한**이 있음
    - 정적 배열: 크기를 초기에 고정해야 함
    - 동적 배열: 확장 시 전체 복사가 필요 → O(n)
2. 메모리가 연속적이어야 하므로 크기가 큰 스택은 메모리 단편화 문제 가능

### 연결 리스트 기반 스택

#### 구조

- 단일 연결 리스트의 head를 스택의 top으로 사용
- push = head에 노드 추가
- pop = head에 노드 제거

#### 특징

- 동적으로 노드를 하나씩 할당하기 때문에 크기 제한이 없음
- 메모리 연속성이 필요 없음

#### 장점

- 스택의 크기에 제한이 없다
- push/pop 모두 head에서 발생
- 배열처럼 확장/재할당 필요 없음

#### 단점

- 각 노드가 참조를 포함하므로 메모리 오버헤드가 존재
- 동적 메모리 할당 비용이 존재
- 캐시 비친화적
- 복잡성 높음

<br>

# 출처

[geeksforgeeks](https://www.geeksforgeeks.org/dsa/abstract-data-types/)  
[baeldung](https://www.baeldung.com/cs/adt)  


